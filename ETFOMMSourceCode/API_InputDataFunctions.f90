! Copyright © 2014
! New Global Systems for Intelligent Transportation Management Corp.
  
! This file is part of ETFOMM.
!
! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU Affero General Public License as
! published by the Free Software Foundation, either version 3 of the
! License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU Affero General Public License for more details.
!
! You should have received a copy of the GNU Affero General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef _TSIS_COMPATIBLE
! ==================================================================================================
  INTEGER FUNCTION SET_RUN_INPUTS[DLLEXPORT, STDCALL](R, S1, S2, S3, L1, L2, L3, L4) RESULT(ERRORS)
  USE SIMPARAMS
  USE SEEDS
  USE FREEWAY_VEHICLES
  USE STREET_VEHICLES
  IMPLICIT NONE                          
  INTEGER, INTENT(IN) :: R, S1, S2, S3, L1, L2, L3, L4
  INTEGER :: ISEED(2)
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    RUN_NUMBER = R
    ISEED1 = S1
    ISEED2 = S2
    ISEED3 = S3
    FSEED = ISEED3
    SSEED = ISEED3
    ISEED(1) = ISEED1
    CALL RANDOM_SEED(PUT = ISEED)
    USE_NTCIP = L1 .EQ. 1
    USE_DCS = L2 .EQ. 1
    LOGGING = L3 .EQ. 1
    USE_EXTERNAL_DETECTORS = L4 .EQ. 1
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SET_NETWORK_INPUTS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE SIMPARAMS
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE STREET_DETECTORS
  USE ACTUATED_CONTROLLERS
  USE SIMPARAMS  
  USE CTEXT
  IMPLICIT NONE
  TYPE(NETWORK_INPUTS) :: INPUTS
  INTEGER :: I
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    TYPE_OF_RUN = INPUTS%TYPE_OF_RUN
    IF(TYPE_OF_RUN .LT. -3 .OR. TYPE_OF_RUN .GT. 4) THEN
      ERROR_COUNT = ERROR_COUNT + 1
      WRITE(MSGTEXT, '(A, I4)') 'INVALID TYPE OF RUN = ', TYPE_OF_RUN
      CALL SENDTEXTMSG(M_ERROR)
      ERRORS = 1
    ELSE
      ERRORS = 0
      N_FREEWAY_LINKS = 0
      N_STREET_LINKS = 0
      NUMBER_OF_ACS = 0
      N_STREET_DETECTORS = 0
      TIME_PERIOD = 1
      TIMESTEP = INPUTS%TIMESTEP
      DO I = 1, 19
        IF(INPUTS%TIME_PERIOD_DURATION(I) .EQ. 0) EXIT
        N_PERIODS = I
        TPSECONDS(I) = INPUTS%TIME_PERIOD_DURATION(I)
      ENDDO
      SIMULATION_END = SUM(TPSECONDS)
      TIME_INTERVAL = INPUTS%TIME_INTERVAL
      SKIP_INIT = INPUTS%RUN_INIT .EQ. 0
      INITIALIZATION_END = INPUTS%INITIALIZATION_END
      SIM_START_TIME =  INPUTS%SIM_START_TIME
    ENDIF
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SET_FREEWAY_NETWORK_INPUTS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE PITT
  USE DRIVERS
  USE GLOBAL_DATA
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(FREEWAY_NETWORK_INPUTS) :: INPUTS
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    LAG_ACCEL = INPUTS%LAG_ACCEL
    LAG_DECEL = INPUTS%LAG_DECEL
    CFRICT = INPUTS%CFRICT
    DEFAULT_HOV_PCT = INPUTS%DEFAULT_HOV_PCT
    FZFOLL = INPUTS%ZFOLL
    FFSPEED_ADJ(1:10, 1) = INPUTS%FFSPEED_ADJ
    FREEWAY_PCT_COOP = INPUTS%FREEWAY_PCT_COOP
    LC_TIME_FREEWAY = INPUTS%LC_TIME
    DLC_MULT = INPUTS%DLC_MULT
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SET_STREET_NETWORK_INPUTS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE PITT
  USE DRIVERS
  USE BUS_STATION_DATA
  USE GLOBAL_DATA
  USE DISTRIBUTIONS
  USE PEDS
  USE EVENTS
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(STREET_NETWORK_INPUTS) :: INPUTS
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    ACCEPTABLE_GAP = INPUTS%ACCEPTABLE_GAP
    ACCEPTABLE_LTG = INPUTS%ACCEPTABLE_LTG    
    ACCEPTABLE_RTG = INPUTS%ACCEPTABLE_RTG
    ADDITIONAL_GAP = INPUTS%ADDITIONAL_GAP
    AMBER_DECEL = INPUTS%AMBER_DECEL
    DWELL_MULTIPLIER = INPUTS%DWELL_MULTIPLIER
    SZFOLL = INPUTS%ZFOLL
    FFSPEED_ADJ(1:10, 2) = INPUTS%FFSPEED_ADJ
    LC_TIME_STREET = INPUTS%LC_TIME
    LT_JUMPER_PROB = INPUTS%LT_JUMPER_PROB
    LT_LAGGER_PROB = INPUTS%LT_LAGGER_PROB
    LT_SPEED = INPUTS%LT_SPEED
    RT_SPEED = INPUTS%RT_SPEED
    SPILLBACK_PROB = INPUTS%SPILLBACK_PROB
    STOP_SPD = INPUTS%STOP_SPD
    STREET_PCT_COOP = INPUTS%STREET_PCT_COOP
    YIELD_SPD = INPUTS%YIELD_SPD
    DRIVER_FAMPCT = INPUTS%DRIVER_FAMPCT
    PDELAY_WEAK = INPUTS%PDELAY_WEAK 
    PDELAY_STRONG = INPUTS%PDELAY_STRONG
    PED_DURATION = INPUTS%PED_DURATION
    QFACTOR = INPUTS%QFACTOR
    STE_MULT = INPUTS%STE_MULT
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_FREEWAYLINKS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE FREEWAY_LINKS
  USE FREEWAY_NODES
  USE SIMPARAMS
  USE API_DATA
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    N_FREEWAY_LINKS = N
    CALL ALLOCATE_FREEWAY_LINK_ARRAYS
    CALL ALLOCATE_FREEWAY_NODE_ARRAYS
    ALLOCATE(FTHRU_PCT(N_FREEWAY_LINKS, N_PERIODS))
    FTHRU_PCT = 0
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_FREEWAYLINKS[DLLEXPORT, STDCALL](LINK_DATA) RESULT(ERRORS)
  USE API_DATA
  USE FREEWAY_LINKS
  USE FREEWAY_NODES
  USE GLOBAL_DATA
  USE NODE_TABLE
  USE SIMPARAMS
  USE CTEXT
  IMPLICIT NONE
  TYPE(FREEWAY_LINK) :: LINK_DATA(N_FREEWAY_LINKS)
  INTEGER :: IL, IADD, IAUX, IL2, ILN, NLINKS, INODE
! ----------------------------------------------------------------------
  ERRORS = 0
  IF(TIME_PERIOD .LE. 1) THEN
    DO IL = 1, N_FREEWAY_LINKS
      FUSN(IL) = LINK_DATA(IL)%USN
      FDSN(IL) = LINK_DATA(IL)%DSN
      IF(FUSN(IL) .LT. 1 .OR. FUSN(IL) .GT. 7999 .OR. FDSN(IL) .LT. 1 .OR. FDSN(IL) .GT. 7999) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, 2I4)') 'ILLEGAL NODE NUMBERS FOR LINK ', FUSN(IL), FDSN(IL)
        CALL SENDTEXTMSG(M_ERROR)
        EXIT
      ENDIF
      IS_USED(FUSN(IL)) = .TRUE.
      IS_USED(FDSN(IL)) = .TRUE.
      IF(FUSN(IL) .LT. 7000 .OR. FUSN(IL) .GT. 7999) NETCODE(FUSN(IL)) = I_FREEWAY
      IF(FDSN(IL) .LT. 7000 .OR. FDSN(IL) .GT. 7999) NETCODE(FDSN(IL)) = I_FREEWAY
      FLENGTH(IL) = LINK_DATA(IL)%LENGTH
      FNUMLANES(IL) = LINK_DATA(IL)%FULLLANES
      IF(FNUMLANES(IL) .LT. 0 .OR. FNUMLANES(IL) .GT. 11) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, 2I5)') 'INVALID NUMBER OF FULL LANES ON LINK ', FUSN(IL), FDSN(IL)
        CALL SENDTEXTMSG(M_ERROR)
        WRITE(MSGTEXT, '(A, I2)') '  NUMBER OF FULL LANES = ', FNUMLANES(IL)
        CALL SENDTEXTMSG(M_ERROR)
      ENDIF
      LINKTYPE(IL) = LINK_DATA(IL)%LINKTYPE
      IF(LINKTYPE(IL) .LT. 0 .OR. LINKTYPE(IL) .GT. 1) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, 2I5)') 'INVALID FREEWAY LINK TYPE CODE ON LINK ', FUSN(IL), FDSN(IL)
        CALL SENDTEXTMSG(M_ERROR)
        WRITE(MSGTEXT, '(A, I2)') '  LINK TYPE CODE = ', LINKTYPE(IL)
        CALL SENDTEXTMSG(M_ERROR)
      ENDIF
      IF(LINK_DATA(IL)%THRUNODE .EQ. 0) THEN
        FTHRU_ALIGNMENT_LANE(IL) = 1
      ELSEIF(LINK_DATA(IL)%THRU_ALIGNMENT_LANE .NE. 0) THEN
        FTHRU_ALIGNMENT_LANE(IL) = LINK_DATA(IL)%THRU_ALIGNMENT_LANE
      ENDIF
      IF(LINK_DATA(IL)%OFFRAMP_ALIGNMENT_LANE .NE. 0) OFFRAMP_ALIGNMENT_LANE(IL) = LINK_DATA(IL)%OFFRAMP_ALIGNMENT_LANE
      DO IADD = 1, 3
        IF(LINK_DATA(IL)%ADDDROP_CODE(IADD) .EQ. 0) EXIT
        ADDDROP_CODE(IL, IADD) = LINK_DATA(IL)%ADDDROP_CODE(IADD)
        ADDDROP_LANE(IL, IADD) = LINK_DATA(IL)%ADDDROP_LANE(IADD) 
        ADDDROP_DIST(IL, IADD) = LINK_DATA(IL)%ADDDROP_DIST(IADD)
        ADDDROP_WARN(IL, IADD) = LINK_DATA(IL)%ADDDROP_WARN(IADD)
      ENDDO
      IF(LINKTYPE(IL) .EQ. 0) THEN
        MAINLINE_APPROACH(FDSN(IL)) = IL
        DO IAUX = 1, 6
          IF(LINK_DATA(IL)%AUXLANEID(IAUX) .EQ. 0) EXIT
          AUX_LANE_ID(IL, IAUX) = LINK_DATA(IL)%AUXLANEID(IAUX)
          AUX_LANE_CODE(IL, IAUX) = LINK_DATA(IL)%AUXLANECODE(IAUX)
          AUX_LANE_LENGTH(IL, IAUX) = LINK_DATA(IL)%AUXLANELENGTH(IAUX)
        ENDDO
      ELSE
        RAMP_APPROACH(FDSN(IL)) = IL
      ENDIF
      FFREEFLOWSPEED(IL) = NINT(LINK_DATA(IL)%FREEFLOWSPEED * 1.467)
      FTHRU_PERCENT(IL) = 100
      IF(LINK_DATA(IL)%CFMULT .NE. 0) FCFMULT(IL) = LINK_DATA(IL)%CFMULT
      FFIRST_DETECTOR(IL) = LINK_DATA(IL)%FIRST_DETECTOR
      FGRADE(IL) = LINK_DATA(IL)%GRADE
      TILT(IL) = LINK_DATA(IL)%TILT
      CURVE(IL) = LINK_DATA(IL)%CURVE
      PAVEMENT(IL) = LINK_DATA(IL)%PAVEMENT
      DO ILN = 1, 11
        IF(LINK_DATA(IL)%LANE_WIDTH(ILN) .NE. 0) FLANE_WIDTH(IL, ILN) = LINK_DATA(IL)%LANE_WIDTH(ILN)
      ENDDO
      IF(LINK_DATA(IL)%SHOULDER_WIDTH .NE. 0) FSHOULDER_WIDTH(IL) = LINK_DATA(IL)%SHOULDER_WIDTH
      BARRIER(IL, 1:2) = LINK_DATA(IL)%BARRIER
      DATASTATION_ID (IL) = LINK_DATA(IL)%DATASTATION_ID
      DATASTATION_LOCATION(IL) = LINK_DATA(IL)%DATASTATION_LOCATION
      TRUCK_CODE(IL) = LINK_DATA(IL)%TRUCK_CODE
      TRUCK_DIR(IL) = LINK_DATA(IL)%TRUCK_DIR
      TRUCK_LANE(IL) = LINK_DATA(IL)%TRUCK_LANE
      ETL_WARN(IL) = LINK_DATA(IL)%ETL_WARN
      FXCLUDE_TYPE(IL, 1:11, 1:NTYPES) = LINK_DATA(IL)%EXCLUDE_TYPE(1:11, 1:NTYPES)
      MULTIPLIER_EXIT(IL, 1:NTYPES) = LINK_DATA(IL)%MULTIPLIER_EXIT
      ANTICIP_WARNING_DISTANCE(IL) = LINK_DATA(IL)%ANTICIP_WARNING_DISTANCE
      IF(LINK_DATA(IL)%ANTICIP_WARNING_SPEED .EQ. 0) THEN
        ANTICIP_WARNING_SPEED(IL) = NINT(2. / 3. * FFREEFLOWSPEED(IL))
      ELSE
        ANTICIP_WARNING_SPEED(IL) = NINT(LINK_DATA(IL)%ANTICIP_WARNING_SPEED * 1.467)
      ENDIF    
      IF(LINK_DATA(IL)%STARTUP_TIME .NE. 0) FSTARTUP_TIME(IL) = LINK_DATA(IL)%STARTUP_TIME
      IF(LINK_DATA(IL)%NHOV_LANES .NE. 0) THEN
        NHOV_LANES(IL) = LINK_DATA(IL)%NHOV_LANES
        IF(NHOV_LANES(IL) .GT. 3) THEN
          NHOV_LANES(IL) = 3
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I5)') 'INVALID NUMBER OF HOV LANES SPECIFIED ON LINK', FUSN(IL), FDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, 2I5)') '  NUMBER OF HOV LANES = ', LINK_DATA(IL)%NHOV_LANES
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
        HOV_SIDE(IL) = LINK_DATA(IL)%HOV_SIDE
        HOV_TYPE(IL) = LINK_DATA(IL)%HOV_TYPE
        HOV_CODE(IL) = LINK_DATA(IL)%HOV_CODE
        HOV_BEGIN(IL) = LINK_DATA(IL)%HOV_BEGIN
        IF(LINK_DATA(IL)%HOV_END .NE. 0) THEN
          HOV_END(IL) = LINK_DATA(IL)%HOV_END
        ELSE
          HOV_END(IL) = FLENGTH(IL)
        ENDIF
        IF(LINK_DATA(IL)%HOV_WARN .NE. 0) THEN
          HOV_WARN(IL) = LINK_DATA(IL)%HOV_WARN
        ELSE
          HOV_WARN(IL) = 5280
        ENDIF
        IF(LINK_DATA(IL)%HOV_PCT .NE. 0) THEN
          HOV_PCT(IL) = LINK_DATA(IL)%HOV_PCT / 100.
        ELSE
          HOV_PCT(IL) = DEFAULT_HOV_PCT
        ENDIF
      ENDIF
    ENDDO
    DO IL = 1, N_FREEWAY_LINKS
      IF(LINK_DATA(IL)%THRUNODE .NE. 0) THEN
        CALL FIND_FREEWAY_LINK(FDSN(IL), LINK_DATA(IL)%THRUNODE, IL2)
        FTHRU_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I5)') 'THRU RECEIVING LINK DOES NOT EXIST ', FUSN(IL), FDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
      FTHRU_PERCENT(IL) = 100
      IF(LINK_DATA(IL)%EXITNODE .NE. 0) THEN
        FTHRU_PERCENT(IL) = LINK_DATA(IL)%THRUPCT
        CALL FIND_FREEWAY_LINK(FDSN(IL), LINK_DATA(IL)%EXITNODE, IL2)
        OFFRAMP_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I5)') 'OFF-RAMP LINK DOES NOT EXIST ', FUSN(IL), FDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
        OFFRAMP_WARN_DISTANCE(IL) = LINK_DATA(IL)%OFFRAMP_WARN_DISTANCE
        SAVE_WARN1(IL) = OFFRAMP_WARN_DISTANCE(IL)
        IF(LINK_DATA(IL)%HOV_OFFRAMP_WARN_DISTANCE .GT. 0) THEN
          HOV_OFFRAMP_WARN_DISTANCE(IL) = LINK_DATA(IL)%HOV_OFFRAMP_WARN_DISTANCE
        ELSE
          HOV_OFFRAMP_WARN_DISTANCE(IL) = OFFRAMP_WARN_DISTANCE(IL)
        ENDIF
        SAVE_WARN2(IL) = HOV_OFFRAMP_WARN_DISTANCE(IL)
      ENDIF
      IF(FUSN(IL) .LT. 8000 .AND. FDSN(IL) .LT. 8000) THEN
        IF(FTHRU_PERCENT(IL) .LT. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I5)') 'NEGATIVE ENTRY FOR THRU PERCENTAGE ON LINK ', FUSN(IL), FDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, I6)') '  THRU PERCENTAGE = ', FTHRU_PERCENT
          CALL SENDTEXTMSG(M_ERROR)
        ELSE
          FTHRU_PCT(IL, 1) = FTHRU_PERCENT(IL)
        ENDIF
      ENDIF
    ENDDO
    NLINKS = N_FREEWAY_LINKS
    DO IL = 1, NLINKS
      IF(FDSN(IL) .LT. 7000 .AND. FTHRU_LINK(IL) .EQ. 0) THEN
        CALL GET_NEXT_8000ID(INODE)
        CALL REALLOCATE_FREEWAY_LINK_ARRAYS
        FUSN(N_FREEWAY_LINKS) = FDSN(IL)
        FDSN(N_FREEWAY_LINKS) = INODE
        LINKTYPE(N_FREEWAY_LINKS) = LINKTYPE(IL)
        FTHRU_LINK(IL) = N_FREEWAY_LINKS
        FNUMLANES(N_FREEWAY_LINKS) = FNUMLANES(IL)
        IF(LINKTYPE(N_FREEWAY_LINKS) .EQ. 0) THEN
          MAINLINE_APPROACH(FDSN(N_FREEWAY_LINKS)) = IL
        ELSE
          RAMP_APPROACH(FDSN(N_FREEWAY_LINKS)) = IL
        ENDIF
      ENDIF
    ENDDO  
  ELSE
    DO IL = 1, N_FREEWAY_LINKS
      IF(FUSN(IL) .GE. 8000 .OR. FDSN(IL) .GE. 8000) EXIT
      IF(LINK_DATA(IL)%EXITNODE .NE. 0) THEN
        FTHRU_PCT(IL, TIME_PERIOD) = LINK_DATA(IL)%THRUPCT
        IF(FTHRU_PERCENT(IL) .NE. LINK_DATA(IL)%THRUPCT) THEN
          WRITE25(IL, TIME_PERIOD) = .TRUE.
          FTHRU_PERCENT(IL) = LINK_DATA(IL)%THRUPCT
          IF(NHOV_LANES(IL) .GT. 0) THEN
            HOV_CODE(IL) = LINK_DATA(IL)%HOV_CODE
            IF(LINK_DATA(IL)%HOV_PCT .NE. 0) THEN
              HOV_PCT(IL) = LINK_DATA(IL)%HOV_PCT / 100.
            ELSE
              HOV_PCT(IL) = DEFAULT_HOV_PCT
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDDO
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_STREETLINKS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE STREET_LINKS
  USE STREET_NODES
  USE SIMPARAMS
  USE API_DATA
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    N_STREET_LINKS = N
    CALL ALLOCATE_STREET_LINK_ARRAYS
    CALL ALLOCATE_STREET_NODE_ARRAYS
    ALLOCATE(LEFT_PCT(N_STREET_LINKS, N_PERIODS))
    ALLOCATE(STHRU_PCT(N_STREET_LINKS, N_PERIODS))
    ALLOCATE(RIGHT_PCT(N_STREET_LINKS, N_PERIODS))
    ALLOCATE(DIAG_PCT(N_STREET_LINKS, N_PERIODS))
    LEFT_PCT = 0
    STHRU_PCT = 0
    RIGHT_PCT = 0
    DIAG_PCT = 0
  ELSE
    ERRORS = 1
  ENDIF
  END 
  
! ==================================================================================================
  INTEGER FUNCTION DEFINE_STREETLINKS[DLLEXPORT, STDCALL](LINK_DATA) RESULT(ERRORS)
  USE API_DATA
  USE STREET_LINKS
  USE NODE_TABLE
  USE GLOBAL_DATA
  USE SIMPARAMS
  USE CTEXT
  IMPLICIT NONE
  TYPE(STREET_LINK) :: LINK_DATA(N_STREET_LINKS)
  INTEGER :: IL, IL2, ILN, NLINKS, INODE, SUM
! ----------------------------------------------------------------------
  ERRORS = 0  
  IF(TIME_PERIOD .LE. 1) THEN
    DO IL = 1, N_STREET_LINKS
      SUSN(IL) = LINK_DATA(IL)%USN 
      SDSN(IL) = LINK_DATA(IL)%DSN
      IF(SUSN(IL) .LT. 1 .OR. SUSN(IL) .GT. 7999 .OR. SDSN(IL) .LT. 1 .OR. SDSN(IL) .GT. 7999) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, 2I4)') 'ILLEGAL NODE NUMBERS FOR LINK ', SUSN(IL), SDSN(IL)
        CALL SENDTEXTMSG(M_ERROR)
        EXIT
      ENDIF
      IF(SDSN(IL) .GE. 7000) THEN
        SUM = LINK_DATA(IL)%LEFTNODE + LINK_DATA(IL)%THRUNODE + LINK_DATA(IL)%RIGHTNODE + ABS(LINK_DATA(IL)%DIAGNODE)
        IF(SUM .NE. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I4)') 'RECEIVING LINK SPECIFIED FOR INTERFACE OR EXIT LINK ', SUSN(IL), SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
      IF(SUSN(IL) .LT. 8000 .AND. SDSN(IL) .LT. 8000) THEN
        LEFT_PCT(IL, 1) = LINK_DATA(IL)%LEFTPCT
        STHRU_PCT(IL, 1) = LINK_DATA(IL)%THRUPCT
        RIGHT_PCT(IL, 1) = LINK_DATA(IL)%RIGHTPCT
        DIAG_PCT(IL, 1) = LINK_DATA(IL)%DIAGPCT
      ENDIF
      IS_USED(SUSN(IL)) = .TRUE.
      IS_USED(SDSN(IL)) = .TRUE.
      IF(SUSN(IL) .LT. 7000 .OR. SUSN(IL) .GT. 7999) NETCODE(SUSN(IL)) = I_STREET
      IF(SDSN(IL) .LT. 7000 .OR. SDSN(IL) .GT. 7999) NETCODE(SDSN(IL)) = I_STREET
      SLENGTH(IL) = LINK_DATA(IL)%LENGTH
      SNUMLANES(IL) = LINK_DATA(IL)%FULLLANES
      IF(SNUMLANES(IL) .LT. 0 .OR. SNUMLANES(IL) .GT. 7) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, 2I5)') 'INVALID NUMBER OF FULL LANES ON LINK ', SUSN(IL), SDSN(IL)
        CALL SENDTEXTMSG(M_ERROR)
        WRITE(MSGTEXT, '(A, I2)') '  NUMBER OF FULL LANES = ', SNUMLANES(IL)
        CALL SENDTEXTMSG(M_ERROR)
      ENDIF
      NUMBER_LEFTPOCKETS(IL) = LINK_DATA(IL)%LEFTTURNBAYS
      NUMBER_RIGHTPOCKETS(IL) = LINK_DATA(IL)%RIGHTTURNBAYS
      LENGTH_LEFTPOCKETS(IL) = LINK_DATA(IL)%LENGTHOFLEFTBAY
      LENGTH_RIGHTPOCKETS(IL) = LINK_DATA(IL)%LENGTHOFRIGHTBAY
      IF(LINK_DATA(IL)%DISTRIBUTION_CODE .NE. 0) THEN
        LINKTYPE_CODE(IL) = LINK_DATA(IL)%DISTRIBUTION_CODE
      ELSE
        LINKTYPE_CODE(IL) = 1
      ENDIF
      SFREEFLOWSPEED(IL) = NINT(LINK_DATA(IL)%FREEFLOWSPEED * 1.467)
      CHANNELIZATION(IL, 1:7) = LINK_DATA(IL)%CHANNELIZATION
      PED_CODE(IL) = LINK_DATA(IL)%PED_CODE
      SGRADE(IL) = LINK_DATA(IL)%GRADE
      IF(LINK_DATA(IL)%STARTUP_DELAY .NE. 0) SSTARTUP_TIME(IL) = LINK_DATA(IL)%STARTUP_DELAY
      IF(SSTARTUP_TIME(IL) .LT. 0 .OR. SSTARTUP_TIME(IL) .GT. 9.9) THEN
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, 2I5)') 'INVALID MEAN STARTUP LOST TIME ON LINK ', SUSN(IL), SDSN(IL)
        CALL SENDTEXTMSG(M_ERROR)
        WRITE(MSGTEXT, '(A, F5.1)') '  VALUE = ', SSTARTUP_TIME(IL)
        CALL SENDTEXTMSG(M_ERROR)
      ENDIF
      IF(LINK_DATA(IL)%DISCHARGE_HDWY .NE. 0) QDISCHARGE_HDWY(IL) = LINK_DATA(IL)%DISCHARGE_HDWY
      ALIGNMENT_LANE(IL) = LINK_DATA(IL)%LANE1
      STHRU_ALIGNMENT_LANE(IL) = LINK_DATA(IL)%LANE2
      IF(LINK_DATA(IL)%CFMULT .NE. 0) SCFMULT(IL) = LINK_DATA(IL)%CFMULT
      IF(LINK_DATA(IL)%SIGHT_DIST .NE. 0) SIGHT_DIST(IL) = LINK_DATA(IL)%SIGHT_DIST
      RTOR(IL) = LINK_DATA(IL)%RTOR .EQ. 0
      SFIRST_DETECTOR(IL) = LINK_DATA(IL)%FIRST_DETECTOR
      SGRADE(IL) = LINK_DATA(IL)%GRADE
      DO ILN = 1, SNUMLANES(IL)
        IF(LINK_DATA(IL)%LANE_WIDTH(ILN) .NE. 0) THEN
          SLANE_WIDTH(IL, ILN) = LINK_DATA(IL)%LANE_WIDTH(ILN)
        ELSE
          SLANE_WIDTH(IL, ILN) = STD_WIDTH
        ENDIF
      ENDDO
      IF(NUMBER_LEFTPOCKETS(IL) .GT. 0) THEN
        DO ILN = 7, 8 - NUMBER_LEFTPOCKETS(IL)
          IF(LINK_DATA(IL)%LANE_WIDTH(ILN) .NE. 0) THEN
            SLANE_WIDTH(IL, ILN) = LINK_DATA(IL)%LANE_WIDTH(ILN)
          ELSE
            SLANE_WIDTH(IL, ILN) = STD_WIDTH
          ENDIF
        ENDDO
      ENDIF
      IF(NUMBER_RIGHTPOCKETS(IL) .GT. 0) THEN
        DO ILN = 7 - NUMBER_LEFTPOCKETS(IL), 7 - NUMBER_LEFTPOCKETS(IL) - NUMBER_RIGHTPOCKETS(IL)
          IF(LINK_DATA(IL)%LANE_WIDTH(ILN) .NE. 0) THEN
            SLANE_WIDTH(IL, ILN) = LINK_DATA(IL)%LANE_WIDTH(ILN)
          ELSE
            SLANE_WIDTH(IL, ILN) = STD_WIDTH
          ENDIF
        ENDDO
      ENDIF
      IF(LINK_DATA(IL)%SHOULDER_WIDTH .NE. 0) SSHOULDER_WIDTH(IL) = LINK_DATA(IL)%SHOULDER_WIDTH
      STE_FREQ(IL) = LINK_DATA(IL)%STE_FREQ
      STE_DURATION(IL) = LINK_DATA(IL)%STE_DURATION
      CENTROID(IL) = LINK_DATA(IL)%CENTROID
      CENTROID_LABEL(IL) = LINK_DATA(IL)%CENTROID_LABEL
      SXCLUDE_TYPE(IL, 1:7, 1:NTYPES) = LINK_DATA(IL)%EXCLUDE_TYPE(1:7, 1:NTYPES)
      MULTIPLIER_LEFT(IL, 1:NTYPES) = LINK_DATA(IL)%MULTIPLIER_LEFT
      MULTIPLIER_THRU(IL, 1:NTYPES) = LINK_DATA(IL)%MULTIPLIER_THRU
      MULTIPLIER_RIGHT(IL, 1:NTYPES) = LINK_DATA(IL)%MULTIPLIER_RIGHT
      MULTIPLIER_DIAG(IL, 1:NTYPES) = LINK_DATA(IL)%MULTIPLIER_DIAG
      LEFT_PERCENT(IL) = LINK_DATA(IL)%LEFTPCT
      STHRU_PERCENT(IL) = LINK_DATA(IL)%THRUPCT
      RIGHT_PERCENT(IL) = LINK_DATA(IL)%RIGHTPCT
      DIAG_PERCENT(IL) = LINK_DATA(IL)%DIAGPCT
    ENDDO
    DO IL = 1, N_STREET_LINKS
      IF(LINK_DATA(IL)%THRUNODE .NE. 0) THEN
        CALL FIND_STREET_LINK(SDSN(IL), LINK_DATA(IL)%THRUNODE, IL2)
        STHRU_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I4)') 'THRU RECEIVING LINK DOES NOT EXIST FOR LINK ', SUSN(IL), SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, 2I5)') '  THRU RECEIVING LINK ', SDSN(IL), LINK_DATA(IL)%THRUNODE
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
      IF(LINK_DATA(IL)%LEFTNODE .NE. 0) THEN
        CALL FIND_STREET_LINK(SDSN(IL), LINK_DATA(IL)%LEFTNODE, IL2)
        LEFT_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I4)') 'LEFT RECEIVING LINK DOES NOT EXIST FOR LINK ', SUSN(IL), SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, 2I5)') '  LEFT RECEIVING LINK ', SDSN(IL), LINK_DATA(IL)%LEFTNODE
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
      IF(LINK_DATA(IL)%RIGHTNODE .NE. 0) THEN
        CALL FIND_STREET_LINK(SDSN(IL), LINK_DATA(IL)%RIGHTNODE, IL2)
        RIGHT_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I4)') 'RIGHT RECEIVING LINK DOES NOT EXIST FOR LINK ', SUSN(IL), SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, 2I5)') '  RIGHT RECEIVING LINK ', SDSN(IL), LINK_DATA(IL)%RIGHTNODE
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
      IF(LINK_DATA(IL)%DIAGNODE .NE. 0) THEN
        CALL FIND_STREET_LINK(SDSN(IL), LINK_DATA(IL)%DIAGNODE, IL2)
        DIAG_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I4)') 'DIAGONAL RECEIVING LINK DOES NOT EXIST FOR LINK ', SUSN(IL), SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, 2I5)') '  DIAGONAL RECEIVING LINK ', SDSN(IL), LINK_DATA(IL)%DIAGNODE
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
      IF(LINK_DATA(IL)%OPPOSENODE .NE. 0) THEN
        CALL FIND_STREET_LINK(LINK_DATA(IL)%OPPOSENODE, SDSN(IL), IL2)
        OPPOSE_LINK(IL) = IL2
        IF(IL2 .EQ. 0) THEN
          ERRORS = ERRORS + 1
          ERROR_COUNT = ERROR_COUNT + 1
          WRITE(MSGTEXT, '(A, 2I4)') 'LINK OPPOSING LEFT TURNS DOES NOT EXIST FOR LINK ', SUSN(IL), SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
          WRITE(MSGTEXT, '(A, 2I5)') '  OPPOSING LINK ', LINK_DATA(IL)%OPPOSENODE, SDSN(IL)
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
      ENDIF
    ENDDO
    NLINKS = N_STREET_LINKS
    DO IL = 1, NLINKS
      IF(SDSN(IL) .LT. 7000) THEN
        SUM = LEFT_LINK(IL) + STHRU_LINK(IL) + RIGHT_LINK(IL) + ABS(DIAG_LINK(IL))
        IF(SUM .EQ. 0) THEN
          CALL GET_NEXT_8000ID(INODE)
          CALL REALLOCATE_STREET_LINK_ARRAYS
          SUSN(N_STREET_LINKS) = SDSN(IL)
          SDSN(N_STREET_LINKS) = INODE
          SNUMLANES(N_STREET_LINKS) = SNUMLANES(IL)
          SFREEFLOWSPEED(N_STREET_LINKS) = SFREEFLOWSPEED(IL)
          LINKTYPE_CODE(N_STREET_LINKS) = 1
          STHRU_LINK(IL) = N_STREET_LINKS
          LEFT_PERCENT(IL) = 0
          STHRU_PERCENT(IL) = 100
          RIGHT_PERCENT(IL) = 0
          DIAG_PERCENT(IL) = 0
          LEFT_PCT(IL, 1) = 0
          STHRU_PCT(IL, 1) = 100
          RIGHT_PCT(IL, 1) = 0
          DIAG_PCT(IL, 1) = 0
        ENDIF
      ENDIF
    ENDDO 
  ELSE
    DO IL = 1, N_STREET_LINKS
      IF(SUSN(IL) .GE. 8000 .OR. SDSN(IL) .GE. 8000) EXIT
      SUM = LINK_DATA(IL)%LEFTPCT + LINK_DATA(IL)%THRUPCT + LINK_DATA(IL)%RIGHTPCT + LINK_DATA(IL)%DIAGPCT
      IF(SUM .EQ. 0) CYCLE
      IF(LEFT_PERCENT(IL) .NE. LINK_DATA(IL)%LEFTPCT .OR. &
         STHRU_PERCENT(IL) .NE.  LINK_DATA(IL)%THRUPCT .OR. &
         RIGHT_PERCENT(IL) .NE. LINK_DATA(IL)%RIGHTPCT .OR. &
         DIAG_PERCENT(IL) .NE. LINK_DATA(IL)%DIAGPCT) THEN
        WRITE21(IL, TIME_PERIOD) = .TRUE.
        LEFT_PERCENT(IL) = LINK_DATA(IL)%LEFTPCT
        STHRU_PERCENT(IL) = LINK_DATA(IL)%THRUPCT
        RIGHT_PERCENT(IL) = LINK_DATA(IL)%RIGHTPCT
        DIAG_PERCENT(IL) = LINK_DATA(IL)%DIAGPCT
        LEFT_PCT(IL, TIME_PERIOD) = LINK_DATA(IL)%LEFTPCT
        STHRU_PCT(IL, TIME_PERIOD) = LINK_DATA(IL)%THRUPCT
        RIGHT_PCT(IL, TIME_PERIOD) = LINK_DATA(IL)%RIGHTPCT
        DIAG_PCT(IL, TIME_PERIOD) = LINK_DATA(IL)%DIAGPCT
      ENDIF
    ENDDO
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_ENTRYNODES[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE API_DATA
  USE FLOWDATA_MOD
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_ENTRYNODES = N
    ALLOCATE(FLOW_RATE(8000:8999, N_PERIODS))
  ELSE
    ERRORS = 1
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION DEFINE_ENTRYNODES[DLLEXPORT, STDCALL](TYPED, ERLA, MNSEP, ENTRY_DATA) RESULT(ERRORS)
  USE API_DATA
  USE ENTRYNODE_DATA
  USE FLOWDATA_MOD
  USE SIMPARAMS
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE GLOBAL_DATA
  USE FREEWAY_NODES
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: TYPED, ERLA
  REAL, INTENT(IN) :: MNSEP
  TYPE(ENTRY_NODE_DATA) :: ENTRY_DATA(NUMBER_OF_ENTRYNODES)
  INTEGER :: I, INODE, IL, START, END, INDEX, NLINKS, NLANES
  LOGICAL :: FOUND, FIRSTCALL = .TRUE.
! ----------------------------------------------------------------------
  IF(N_FREEWAY_LINKS + N_STREET_LINKS .EQ. 0) THEN
    ERRORS = 1
  ELSE
    ERRORS = 0
    TYPEDIST = TYPED
    ERLANGA = ERLA
    MINSEP = MNSEP
    IF(TIME_PERIOD .LE. 1 .AND. FIRSTCALL) THEN
      FIRSTCALL = .FALSE.
      DO I = 1, NUMBER_OF_ENTRYNODES
        IF(ENTRY_DATA(I)%SS_USN .GE. 1 .AND. ENTRY_DATA(I)%SS_USN .LE. 6999) THEN
          FOUND = .FALSE.
          DO IL = 1, N_STREET_LINKS
          IF(SUSN(IL) .EQ. ENTRY_DATA(I)%SS_USN .AND. SDSN(IL) .EQ. ENTRY_DATA(I)%SS_DSN) THEN
            CENTROID_LABEL(IL) = ENTRY_DATA(I)%NODE_ID
            ENTRYLINK(I)%CARDTYPE = 51
            ENTRYLINK(I)%LINKID = IL
            ENTRYLINK(I)%UP = SUSN(IL)
            ENTRYLINK(I)%DOWN = SDSN(IL)
            ENTRYLINK(I)%NETWORK = I_STREET
            INDEX = 1
            ENTRYLINK(I)%INDEX = INDEX
            ENTRYLINK(I)%TIME(INDEX) = 0
            ENTRYLINK(I)%FLOW(INDEX) = ENTRY_DATA(I)%FLOWRATE
            INDEX = 2
            ENTRYLINK(I)%INDEX = INDEX
            ENTRYLINK(I)%TIME(INDEX) = TPSECONDS(1) / 60.
            ENTRYLINK(I)%FLOW(INDEX) = ENTRY_DATA(I)%FLOWRATE
            FOUND = .TRUE.
            EXIT
          ENDIF
        ENDDO
        IF(.NOT. FOUND) THEN
          ERRORS = ERRORS + 1
          RETURN
        ENDIF
      ELSE
          CALL GET_NEXT_8000ID(INODE)
          FLOW_RATE(INODE, 1) = ENTRY_DATA(I)%FLOWRATE
          ENTRYLINK(I)%TIME(1) = 0
          ENTRYLINK(I)%FLOW(1) = ENTRY_DATA(I)%FLOWRATE
          ENTRYLINK(I)%TIME(2) = TPSECONDS(1) / 60.
          ENTRYLINK(I)%FLOW(2) = ENTRY_DATA(I)%FLOWRATE
          ENTRYLINK(I)%INDEX = 2
          FOUND = .FALSE.
          NLINKS = N_FREEWAY_LINKS
          DO IL = 1, NLINKS
            IF(FUSN(IL) .EQ. ENTRY_DATA(I)%NODE_ID) THEN
              CALL REALLOCATE_FREEWAY_LINK_ARRAYS
              FUSN(N_FREEWAY_LINKS) = INODE
              FDSN(N_FREEWAY_LINKS) = FUSN(IL)
              LINKTYPE(N_FREEWAY_LINKS) = LINKTYPE(IL)
              FTHRU_LINK(N_FREEWAY_LINKS) = IL
              FNUMLANES(N_FREEWAY_LINKS) = FNUMLANES(IL)
              FTHRU_ALIGNMENT_LANE(N_FREEWAY_LINKS) = 1
              FTHRU_PERCENT(N_FREEWAY_LINKS) = 100
              IF(LINKTYPE(N_FREEWAY_LINKS) .EQ. 0) THEN
                MAINLINE_APPROACH(FUSN(IL)) = N_FREEWAY_LINKS
              ELSE
                RAMP_APPROACH(FUSN(IL)) = N_FREEWAY_LINKS
              ENDIF
              ENTRYLINK(I)%LINKID = N_FREEWAY_LINKS
              ENTRYLINK(I)%UP = INODE
              ENTRYLINK(I)%DOWN = FDSN(N_FREEWAY_LINKS)
              ENTRYLINK(I)%NETWORK = I_FREEWAY
              NLANES = MAX(FNUMLANES(IL), 1)
              NLANES = MIN(FNUMLANES(IL), 5)
              IF(SUM(ENTRY_DATA(I)%LANE_PCT) .EQ. 100) THEN
                LANE_PCT(INODE, 1:NLANES) = ENTRY_DATA(I)%LANE_PCT(1:NLANES) / 100.
              ELSE
                LANE_PCT(INODE, 1:NLANES) = 1.0 / NLANES
              ENDIF
              FOUND = .TRUE.
              EXIT
            ENDIF
          ENDDO
          IF(.NOT. FOUND) THEN
            NLINKS = N_STREET_LINKS
            DO IL = 1, NLINKS
              IF(SUSN(IL) .EQ. ENTRY_DATA(I)%NODE_ID) THEN
                CALL REALLOCATE_STREET_LINK_ARRAYS
                SUSN(N_STREET_LINKS) = INODE
                SDSN(N_STREET_LINKS) = SUSN(IL)
                STHRU_LINK(N_STREET_LINKS) = IL
                STHRU_PERCENT(N_STREET_LINKS) = 100
                SNUMLANES(N_STREET_LINKS) = SNUMLANES(IL)
                LINKTYPE_CODE(N_STREET_LINKS) = 1
                ENTRYLINK(I)%LINKID = N_STREET_LINKS
                ENTRYLINK(I)%UP = INODE
                ENTRYLINK(I)%DOWN = SDSN(N_STREET_LINKS)
                ENTRYLINK(I)%NETWORK = I_STREET
                NLANES = MAX(SNUMLANES(IL), 1)
                NLANES = MIN(SNUMLANES(IL), 5)
                IF(SUM(ENTRY_DATA(I)%LANE_PCT) .NE. 0) THEN
                  LANE_PCT(INODE, 1:NLANES) = ENTRY_DATA(I)%LANE_PCT(1:NLANES) / 100.
                ELSE
                  LANE_PCT(INODE, 1:NLANES) = 1.0 / NLANES
                ENDIF
                FOUND = .TRUE.
                EXIT
              ENDIF
            ENDDO
          ENDIF
          IF(FOUND) THEN
            ENTRYNODE_IS_USED(INODE) = .TRUE.
            FLOWRATE(INODE) = ENTRY_DATA(I)%FLOWRATE
            TRUCK_PCT(INODE) = ENTRY_DATA(I)%TRUCK_PCT
            CARPOOL_PCT(INODE) = ENTRY_DATA(I)%CARPOOL_PCT
            HOV_VIOLATOR_PCT(INODE) = ENTRY_DATA(I)%HOV_VIOLATORS_PER10000 / 10000.
          ENDIF
        ENDIF
      ENDDO
    ELSE
      START = SIMTIME
      END = SUM(TPSECONDS(1:TIME_PERIOD))
      DO I = 1, NUMBER_OF_ENTRYNODES
        INODE = ENTRYLINK(I)%UP
        INDEX = ENTRYLINK(I)%INDEX
        IF(INODE .LT. 8000) THEN
          IF(ENTRYLINK(I)%FLOW(INDEX) .NE. ENTRY_DATA(I)%FLOWRATE) THEN
            WRITE51(INODE, TIME_PERIOD) = .TRUE.
          ENDIF
          IF(WRITE51(INODE, TIME_PERIOD)) THEN
            ENTRYLINK(I)%TIME(INDEX) = INT(START / 60.)
            ENTRYLINK(I)%FLOW(INDEX) = ENTRY_DATA(I)%FLOWRATE
            ENTRYLINK(I)%TIME(INDEX + 1) = INT(END / 60.)
            ENTRYLINK(I)%FLOW(INDEX + 1) = ENTRY_DATA(I)%FLOWRATE
            ENTRYLINK(I)%INDEX = INDEX + 2
          ENDIF
        ELSE
          IF(SIMTIME .EQ. SUM(TPSECONDS(1:TIME_PERIOD-1)) + TIMESTEP) THEN
            IF(FLOWRATE(INODE) .NE. ENTRY_DATA(I)%FLOWRATE) THEN
              WRITE50(INODE, TIME_PERIOD) = .TRUE.
            ELSEIF(TRUCK_PCT(INODE) .NE. ENTRY_DATA(I)%TRUCK_PCT) THEN
              WRITE50(INODE, TIME_PERIOD) = .TRUE.
            ELSEIF(CARPOOL_PCT(INODE) .NE. ENTRY_DATA(I)%CARPOOL_PCT) THEN
              WRITE50(INODE, TIME_PERIOD) = .TRUE.
            ELSEIF(HOV_VIOLATOR_PCT(INODE) .NE. ENTRY_DATA(I)%HOV_VIOLATORS_PER10000 / 10000.) THEN
              WRITE50(INODE, TIME_PERIOD) = .TRUE.
            ENDIF
            IF(WRITE50(INODE, TIME_PERIOD)) THEN
              FLOW_RATE(INODE, TIME_PERIOD) = ENTRY_DATA(I)%FLOWRATE
              FLOWRATE(INODE) = ENTRY_DATA(I)%FLOWRATE
              ENTRYLINK(I)%TIME(INDEX + 1) = START / 60.
              ENTRYLINK(I)%FLOW(INDEX + 1) = ENTRY_DATA(I)%FLOWRATE
              ENTRYLINK(I)%TIME(INDEX + 2) = END / 60.
              ENTRYLINK(I)%FLOW(INDEX + 2) = ENTRY_DATA(I)%FLOWRATE
              ENTRYLINK(I)%INDEX = INDEX + 2
              TRUCK_PCT(INODE) = ENTRY_DATA(I)%TRUCK_PCT
              CARPOOL_PCT(INODE) = ENTRY_DATA(I)%CARPOOL_PCT
              HOV_VIOLATOR_PCT(INODE) = ENTRY_DATA(I)%HOV_VIOLATORS_PER10000 / 10000.
              IF(SUM(ENTRY_DATA(I)%LANE_PCT) .NE. 0) THEN
                LANE_PCT(INODE, 1:NLANES) = ENTRY_DATA(I)%LANE_PCT(1:NLANES) / 100.
              ELSE
                LANE_PCT(INODE, 1:NLANES) = 1.0 / NLANES
              ENDIF
            ENDIF
          ELSE
            IF(FLOWRATE(INODE) .NE. ENTRY_DATA(I)%FLOWRATE) THEN
              WRITE53(INODE, TIME_PERIOD) = .TRUE.
              FLOW_RATE(INODE, TIME_PERIOD) = ENTRY_DATA(I)%FLOWRATE
              FLOWRATE(INODE) = ENTRY_DATA(I)%FLOWRATE
              ENTRYLINK(I)%TIME(INDEX) = START / 60.
              ENTRYLINK(I)%TIME(INDEX + 1) = START / 60. + 1
              ENTRYLINK(I)%FLOW(INDEX + 1) = ENTRY_DATA(I)%FLOWRATE
              ENTRYLINK(I)%TIME(INDEX + 2) = END / 60.
              ENTRYLINK(I)%FLOW(INDEX + 2) = ENTRY_DATA(I)%FLOWRATE
              ENTRYLINK(I)%INDEX = INDEX + 2
            ENDIF
          ENDIF
        ENDIF
      ENDDO
    ENDIF
  ENDIF
  END
   
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_FTC_SIGNALS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE TIMED_CONTROLLERS
  USE SIMPARAMS
  USE API_DATA
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_FTCS = N
    CALL ALLOCATE_FTC_ARRAYS
    ALLOCATE(DURATIONS(N, 12, N_PERIODS))
    DURATIONS = 0
    ALLOCATE(SIGCODES(N, 5, 12, N_PERIODS))
    SIGCODES = 0
    ALLOCATE(WRITE3536(N, N_PERIODS))
    WRITE3536 = .FALSE.
  ELSE
    ERRORS = 1
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION DEFINE_FTC_SIGNALS[DLLEXPORT, STDCALL](SIGNALDATA) RESULT(ERRORS)
  USE TIMED_CONTROLLERS
  USE STREET_LINKS
  USE STREET_NODES
  USE SIMPARAMS
  USE API_DATA 
  USE CTEXT
  IMPLICIT NONE
  TYPE(FTC_DATA) :: SIGNALDATA(NUMBER_OF_FTCS)
  INTEGER :: I, J, NODE, IL, OFFSET, INT, ILX, K
! ----------------------------------------------------------------------
  ERRORS = 0
  IF(TIME_PERIOD .LE. 1) THEN
    DO I = 1, NUMBER_OF_FTCS
      NODE = SIGNALDATA(I)%NODE
      IF(NODE .LT. 1 .OR. NODE .GT. 6999) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, I4)') 'INVALID NODE SPECIFIED FOR FIXED-TIME CONTROL ', NODE
        CALL SENDTEXTMSG(M_ERROR)
        EXIT
      ELSE
        NFTC(NODE) = I
        FTC_SIGNALS(I) = SIGNALDATA(I)
        DURATIONS(I, 1:12, 1) = SIGNALDATA(I)%DURATION(1:12)
        DO J = 1, FTC_SIGNALS(I)%APPROACHES
          IF(FTC_SIGNALS(I)%APPROACH(J) .EQ. 0) THEN
            IL = 0
            DO ILX = 1, N_STREET_LINKS
              IF(SUSN(ILX) .GE. 8000 .AND. SDSN(ILX) .EQ. NODE) THEN
                IL = ILX
                EXIT
              ENDIF
            ENDDO
          ELSE
            CALL FIND_STREET_LINK(FTC_SIGNALS(I)%APPROACH(J), NODE, IL)
          ENDIF
          IF(IL .EQ. 0) THEN
            ERRORS = ERRORS + 1
            ERROR_COUNT = ERROR_COUNT + 1
            WRITE(MSGTEXT, '(A, I5)') 'APPROACH NODE NOT FOUND FOR FTC SIGNAL AT NODE ', NODE
            CALL SENDTEXTMSG(M_ERROR)
            WRITE(MSGTEXT, '(A, I4)') '  APPROACH NODE = ', FTC_SIGNALS(I)%APPROACH(J)
            CALL SENDTEXTMSG(M_ERROR)
          ELSE
            FTC_SIGNALS(I)%APPROACH(J) = IL
            FTC_SIGNAL_ID(IL) = I
            APPROACH_NUM(IL) = J
            IF(FTC_SIGNALS(I)%ACTIVE_INTERVALS .EQ. 1) THEN
              IF(FTC_SIGNALS(I)%SIGNAL_CODE(J, 1) .EQ. 0) THEN
                FTC_SIGNALS(I)%SIGNAL_CODE(J, 1) = S_YIELD
              ELSEIF(FTC_SIGNALS(I)%SIGNAL_CODE(J, 1) .EQ. 1) THEN
                FTC_SIGNALS(I)%SIGNAL_CODE(J, 1) = S_PERGRN
              ELSEIF(FTC_SIGNALS(I)%SIGNAL_CODE(J, 1) .EQ. 5) THEN
                FTC_SIGNALS(I)%SIGNAL_CODE(J, 1) = S_STOP
              ENDIF
            ELSE
              SIGNALIZED(IL) = .TRUE.
            ENDIF
            SIGNAL_CODE(IL) = FTC_SIGNALS(I)%SIGNAL_CODE(J, 1)
          ENDIF
        ENDDO
        IF(FTC_SIGNALS(I)%ACTIVE_INTERVALS .GT. 1) NUMBER_OF_FTSIGNALS = NUMBER_OF_FTSIGNALS + 1
        FTC_SIGNALS(I)%CURRENT_INTERVAL = 1
        OFFSET = FTC_SIGNALS(I)%OFFSET
        IF(OFFSET .NE. 0) THEN
          INT = FTC_SIGNALS(I)%ACTIVE_INTERVALS
          DO WHILE(OFFSET .GT. 0)
            OFFSET = OFFSET - FTC_SIGNALS(I)%DURATION(INT)
            INT = INT - 1
          ENDDO
          INT = INT + 1
          FTC_SIGNALS(I)%CURRENT_INTERVAL = INT
          FTC_SIGNALS(I)%TIME_IN_INTERVAL = -OFFSET     
        ENDIF
        FTC_SIGNALS(I)%CYCLE_LENGTH = SUM(FTC_SIGNALS(I)%DURATION)
      ENDIF
      SIGCODES(I, 1:5, 1:12, 1) = SIGNALDATA(I)%SIGNAL_CODE
    ENDDO
  ELSE
    DO I = 1, NUMBER_OF_FTCS
      IF(FTC_SIGNALS(I)%ACTIVE_INTERVALS .GT. 1) THEN
        DO J = 1, 12
          IF(FTC_SIGNALS(I)%DURATION(J) .NE. SIGNALDATA(I)%DURATION(J)) THEN
            WRITE3536(I, TIME_PERIOD) = .TRUE.
            GOTO 100
          ENDIF
          DO K = 1, 5
            IF(FTC_SIGNALS(I)%SIGNAL_CODE(J,K) .NE. SIGNALDATA(I)%SIGNAL_CODE(J,K)) THEN
              WRITE3536(I, TIME_PERIOD) = .TRUE.
              GOTO 100
            ENDIF
          ENDDO
        ENDDO
      ENDIF
    ENDDO
100 CONTINUE      
    IF(WRITE3536(I, TIME_PERIOD)) THEN
      DO J = 1, 5
        DO K = 1, 12
          WRITE3536(I, TIME_PERIOD) = .TRUE.
          FTC_SIGNALS(I)%DURATION = SIGNALDATA(I)%DURATION
          FTC_SIGNALS(I)%SIGNAL_CODE = SIGNALDATA(I)%SIGNAL_CODE
          DURATIONS(I, 1:12, TIME_PERIOD) = SIGNALDATA(I)%DURATION(1:12)
          SIGCODES(I, 1:5, 1:12, TIME_PERIOD) = SIGNALDATA(I)%SIGNAL_CODE
        ENDDO
      ENDDO
    ENDIF
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_AC_SIGNALS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE ACTUATED_CONTROLLERS
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_ACS = N
    CALL ALLOCATE_AC_ARRAYS
    ALLOCATE(ACSIGNAL_DATA(NUMBER_OF_ACS, N_PERIODS))
    ALLOCATE(WRITE4X(N, N_PERIODS))
    WRITE4X = .FALSE.
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_COORDINATION[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE ACTUATED_CONTROLLERS
  USE STREET_NODES
  IMPLICIT NONE
  TYPE(COORDINATION_INPUTS) :: INPUTS
  INTEGER :: IACT
! ----------------------------------------------------------------------
  ERRORS = 0
  IACT = NACT(INPUTS%NODE)
  IF(IACT .EQ. 0) THEN
    ERRORS = 1
  ELSE
    AC_SIGNALS(IACT)%CYCLE_LENGTH = INPUTS%CYCLE_LENGTH
    AC_SIGNALS(IACT)%OFFSET = INPUTS%OFFSET
    AC_SIGNALS(IACT)%COORDINATED = .TRUE.
    NEED_MASTER_CLOCK = .TRUE.
  ENDIF
  END
    
! ==================================================================================================
  INTEGER FUNCTION DEFINE_AC_SIGNALS[DLLEXPORT, STDCALL](AC_DATA_INPUTS) RESULT(ERRORS)
  USE ACTUATED_CONTROLLERS
  USE STREET_NODES
  USE API_DATA
  USE STREET_DETECTORS
  USE STREET_LINKS
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(API_ACTUATED_DATA) :: AC_DATA_INPUTS(NUMBER_OF_ACS)
  INTEGER :: IACT, NODE, PHASE, IAP, IL
! ----------------------------------------------------------------------
  ERRORS = 0    
  IF(TIME_PERIOD .LE. 1) THEN
    DO IACT = 1, NUMBER_OF_ACS
      NODE = AC_DATA_INPUTS(IACT)%NODE
      IF(NODE .LT. 1 .OR. NODE .GT. 6999) THEN
        ERRORS = ERRORS + 1
        EXIT
      ELSE
        NACT(NODE) = IACT
        AC_SIGNALS(IACT)%NODE = NODE
        AC_SIGNALS(IACT)%DIRECT_APPROACHES = AC_DATA_INPUTS(IACT)%DIRECT_APPROACHES
        DO IAP = 1, AC_SIGNALS(IACT)%DIRECT_APPROACHES
          IL = AC_DATA_INPUTS(IACT)%DIRECT_APPROACH(IAP)
          AC_SIGNALS(IACT)%DIRECT_APPROACH(IAP) = IL
          SIGNALIZED(IL) = .TRUE.
          AC_SIGNAL_ID(IL) = IACT
        ENDDO
        AC_SIGNALS(IACT)%SDP%CONSECUTIVE_FAILURES = AC_DATA_INPUTS(IACT)%CFAILS
        AC_SIGNALS(IACT)%SDP%ADJUSTMENT = AC_DATA_INPUTS(IACT)%ADJ
        AC_SIGNALS(IACT)%GUI%NEW_ACTUATED_MODE(1:8) = AC_DATA_INPUTS(IACT)%ACTUATED_MODE(1:8)
        AC_SIGNALS(IACT)%GUI%NEW_MIN_GREEN_TIMES = AC_DATA_INPUTS(IACT)%MIN_GREEN_TIME
        AC_SIGNALS(IACT)%GUI%NEW_MAX_GREEN_ORIGINAL = AC_DATA_INPUTS(IACT)%MAX_GREEN_TIME
        AC_SIGNALS(IACT)%GUI%NEW_DEFAULT_EXTENSION_TIMES = AC_DATA_INPUTS(IACT)%DEFAULT_EXTENSION_TIME
        AC_SIGNALS(IACT)%GUI%NEW_GAP_TIMES = AC_DATA_INPUTS(IACT)%GAP_TIME
        AC_SIGNALS(IACT)%GUI%NEW_TIMES_BEFORE_REDUCTION = AC_DATA_INPUTS(IACT)%TIMES_BEFORE_REDUCTION
        AC_SIGNALS(IACT)%GUI%NEW_TIME_TO_REDUCE = AC_DATA_INPUTS(IACT)%TIME_TO_REDUCE
        AC_SIGNALS(IACT)%GUI%NEW_MIN_GAP_TIMES = AC_DATA_INPUTS(IACT)%MIN_GAP_TIME
        AC_SIGNALS(IACT)%GUI%NEW_YC = AC_DATA_INPUTS(IACT)%YC
        AC_SIGNALS(IACT)%GUI%NEW_RC = AC_DATA_INPUTS(IACT)%RC
        AC_SIGNALS(IACT)%GUI%NEW_PED_WALK_TIMES = AC_DATA_INPUTS(IACT)%WALK_TIME
        AC_SIGNALS(IACT)%GUI%NEW_PED_CLEARANCE_TIMES = AC_DATA_INPUTS(IACT)%WALK_CLEARANCE_TIME
        DO PHASE = 1, 8
          AC_SIGNALS(IACT)%PHASE(PHASE)%IN_USE = .TRUE.
          AC_SIGNALS(IACT)%PHASE(PHASE)%LEFTARROW(1:5) = AC_DATA_INPUTS(IACT)%LEFTARROW(PHASE, 1:5)
          AC_SIGNALS(IACT)%PHASE(PHASE)%THRUARROW(1:5) = AC_DATA_INPUTS(IACT)%THRUARROW(PHASE, 1:5)
          AC_SIGNALS(IACT)%PHASE(PHASE)%RIGHTARROW(1:5) = AC_DATA_INPUTS(IACT)%RIGHTARROW(PHASE, 1:5)
          DO IAP = 1, 5
            AC_SIGNALS(IACT)%PHASE(PHASE)%LEFTARROW(IAP) = AC_DATA_INPUTS(IACT)%LEFTARROW(PHASE, IAP)
            AC_SIGNALS(IACT)%PHASE(PHASE)%THRUARROW(IAP) = AC_DATA_INPUTS(IACT)%THRUARROW(PHASE, IAP)
            AC_SIGNALS(IACT)%PHASE(PHASE)%RIGHTARROW(IAP) = AC_DATA_INPUTS(IACT)%RIGHTARROW(PHASE, IAP)
            AC_SIGNALS(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
            AC_SIGNALS(IACT)%PHASE(PHASE)%RDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
            IF(AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP) .GE. 0) THEN
              AC_SIGNALS(IACT)%PHASE(PHASE)%RDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
            ELSE
              AC_SIGNALS(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
            ENDIF
          ENDDO
        ENDDO
        DO IAP = 1, AC_SIGNALS(IACT)%DIRECT_APPROACHES
          IL = AC_DATA_INPUTS(IACT)%DIRECT_APPROACH(IAP)
          DO PHASE = 1, 8
            IF(AC_SIGNALS(IACT)%PHASE(PHASE)%LEFTARROW(IAP)) PHASE_LEFT(IL) = PHASE
            IF(AC_SIGNALS(IACT)%PHASE(PHASE)%THRUARROW(IAP)) PHASE_THRU(IL) = PHASE
            IF(AC_SIGNALS(IACT)%PHASE(PHASE)%RIGHTARROW(IAP)) PHASE_RIGHT(IL) = PHASE
            IF(AC_SIGNALS(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) .OR. AC_SIGNALS(IACT)%PHASE(PHASE)%RDIAGARROW(IAP)) PHASE_DIAG(IL) = PHASE
          ENDDO
        ENDDO
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(1, 1) = AC_DATA_INPUTS(IACT)%RING_PHASE(1, 1)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(1, 2) = AC_DATA_INPUTS(IACT)%RING_PHASE(1, 2)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(1, 3) = AC_DATA_INPUTS(IACT)%RING_PHASE(1, 3)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(1, 4) = AC_DATA_INPUTS(IACT)%RING_PHASE(1, 4)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(2, 1) = AC_DATA_INPUTS(IACT)%RING_PHASE(2, 1)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(2, 2) = AC_DATA_INPUTS(IACT)%RING_PHASE(2, 2)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(2, 3) = AC_DATA_INPUTS(IACT)%RING_PHASE(2, 3)
        AC_SIGNALS(IACT)%RING_PHASE_SEQUENCE(2, 4) = AC_DATA_INPUTS(IACT)%RING_PHASE(2, 4)
      ENDIF
      ACSIGNAL_DATA(IACT, 1) = AC_SIGNALS(IACT)
    ENDDO
  ELSE
    DO IACT = 1, NUMBER_OF_ACS
      AC_SIGNALS(IACT)%SDP%CONSECUTIVE_FAILURES = AC_DATA_INPUTS(IACT)%CFAILS
      AC_SIGNALS(IACT)%SDP%ADJUSTMENT = AC_DATA_INPUTS(IACT)%ADJ
      AC_SIGNALS(IACT)%GUI%NEW_ACTUATED_MODE(1:8) = AC_DATA_INPUTS(IACT)%ACTUATED_MODE(1:8)
      AC_SIGNALS(IACT)%GUI%NEW_MIN_GREEN_TIMES = AC_DATA_INPUTS(IACT)%MIN_GREEN_TIME
      AC_SIGNALS(IACT)%GUI%NEW_MAX_GREEN_ORIGINAL = AC_DATA_INPUTS(IACT)%MAX_GREEN_TIME
      AC_SIGNALS(IACT)%GUI%NEW_DEFAULT_EXTENSION_TIMES = AC_DATA_INPUTS(IACT)%DEFAULT_EXTENSION_TIME
      AC_SIGNALS(IACT)%GUI%NEW_GAP_TIMES = AC_DATA_INPUTS(IACT)%GAP_TIME
      AC_SIGNALS(IACT)%GUI%NEW_TIMES_BEFORE_REDUCTION = AC_DATA_INPUTS(IACT)%TIMES_BEFORE_REDUCTION
      AC_SIGNALS(IACT)%GUI%NEW_TIME_TO_REDUCE = AC_DATA_INPUTS(IACT)%TIME_TO_REDUCE
      AC_SIGNALS(IACT)%GUI%NEW_MIN_GAP_TIMES = AC_DATA_INPUTS(IACT)%MIN_GAP_TIME
      AC_SIGNALS(IACT)%GUI%NEW_YC = AC_DATA_INPUTS(IACT)%YC
      AC_SIGNALS(IACT)%GUI%NEW_RC = AC_DATA_INPUTS(IACT)%RC
      AC_SIGNALS(IACT)%GUI%NEW_PED_WALK_TIMES = AC_DATA_INPUTS(IACT)%WALK_TIME
      AC_SIGNALS(IACT)%GUI%NEW_PED_CLEARANCE_TIMES = AC_DATA_INPUTS(IACT)%WALK_CLEARANCE_TIME
      DO PHASE = 1, 8
        AC_SIGNALS(IACT)%PHASE(PHASE)%IN_USE = .TRUE.
        AC_SIGNALS(IACT)%PHASE(PHASE)%LEFTARROW(1:5) = AC_DATA_INPUTS(IACT)%LEFTARROW(PHASE, 1:5)
        AC_SIGNALS(IACT)%PHASE(PHASE)%THRUARROW(1:5) = AC_DATA_INPUTS(IACT)%THRUARROW(PHASE, 1:5)
        AC_SIGNALS(IACT)%PHASE(PHASE)%RIGHTARROW(1:5) = AC_DATA_INPUTS(IACT)%RIGHTARROW(PHASE, 1:5)
        DO IAP = 1, 5
          AC_SIGNALS(IACT)%PHASE(PHASE)%LEFTARROW(IAP) = AC_DATA_INPUTS(IACT)%LEFTARROW(PHASE, IAP)
          AC_SIGNALS(IACT)%PHASE(PHASE)%THRUARROW(IAP) = AC_DATA_INPUTS(IACT)%THRUARROW(PHASE, IAP)
          AC_SIGNALS(IACT)%PHASE(PHASE)%RIGHTARROW(IAP) = AC_DATA_INPUTS(IACT)%RIGHTARROW(PHASE, IAP)
          AC_SIGNALS(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
          AC_SIGNALS(IACT)%PHASE(PHASE)%RDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
          IF(AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP) .GE. 0) THEN
            AC_SIGNALS(IACT)%PHASE(PHASE)%RDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
          ELSE
            AC_SIGNALS(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
          ENDIF
        ENDDO
      ENDDO
      ACSIGNAL_DATA(IACT, TIME_PERIOD) = AC_SIGNALS(IACT)
    ENDDO
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION REDEFINE_AC_SIGNALS[DLLEXPORT, STDCALL](AC_DATA_INPUTS) RESULT(ERRORS)
  USE ACTUATED_CONTROLLERS
  USE STREET_NODES
  USE API_DATA
  USE STREET_DETECTORS
  USE STREET_LINKS
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(API_ACTUATED_DATA) :: AC_DATA_INPUTS(NUMBER_OF_ACS)
  INTEGER :: IACT, NODE, PHASE, IAP, IL
! ----------------------------------------------------------------------
  ERRORS = 0    
  DO IACT = 1, NUMBER_OF_ACS
    AC_SIGNALS(IACT)%NEWPLAN = .TRUE.
    AC_TEMP(IACT) = AC_SIGNALS(IACT)
    AC_TEMP(IACT)%SDP%CONSECUTIVE_FAILURES = AC_DATA_INPUTS(IACT)%CFAILS
    AC_TEMP(IACT)%SDP%ADJUSTMENT = AC_DATA_INPUTS(IACT)%ADJ
    AC_TEMP(IACT)%GUI%NEW_ACTUATED_MODE(1:8) = AC_DATA_INPUTS(IACT)%ACTUATED_MODE(1:8)
    AC_TEMP(IACT)%GUI%NEW_MIN_GREEN_TIMES = AC_DATA_INPUTS(IACT)%MIN_GREEN_TIME
    AC_TEMP(IACT)%GUI%NEW_MAX_GREEN_ORIGINAL = AC_DATA_INPUTS(IACT)%MAX_GREEN_TIME
    AC_TEMP(IACT)%GUI%NEW_DEFAULT_EXTENSION_TIMES = AC_DATA_INPUTS(IACT)%DEFAULT_EXTENSION_TIME
    AC_TEMP(IACT)%GUI%NEW_GAP_TIMES = AC_DATA_INPUTS(IACT)%GAP_TIME
    AC_TEMP(IACT)%GUI%NEW_TIMES_BEFORE_REDUCTION = AC_DATA_INPUTS(IACT)%TIMES_BEFORE_REDUCTION
    AC_TEMP(IACT)%GUI%NEW_TIME_TO_REDUCE = AC_DATA_INPUTS(IACT)%TIME_TO_REDUCE
    AC_TEMP(IACT)%GUI%NEW_MIN_GAP_TIMES = AC_DATA_INPUTS(IACT)%MIN_GAP_TIME
    AC_TEMP(IACT)%GUI%NEW_YC = AC_DATA_INPUTS(IACT)%YC
    AC_TEMP(IACT)%GUI%NEW_RC = AC_DATA_INPUTS(IACT)%RC
    AC_TEMP(IACT)%GUI%NEW_PED_WALK_TIMES = AC_DATA_INPUTS(IACT)%WALK_TIME
    AC_TEMP(IACT)%GUI%NEW_PED_CLEARANCE_TIMES = AC_DATA_INPUTS(IACT)%WALK_CLEARANCE_TIME
    DO PHASE = 1, 8
      AC_TEMP(IACT)%PHASE(PHASE)%IN_USE = .TRUE.
      AC_TEMP(IACT)%PHASE(PHASE)%LEFTARROW(1:5) = AC_DATA_INPUTS(IACT)%LEFTARROW(PHASE, 1:5)
      AC_TEMP(IACT)%PHASE(PHASE)%THRUARROW(1:5) = AC_DATA_INPUTS(IACT)%THRUARROW(PHASE, 1:5)
      AC_TEMP(IACT)%PHASE(PHASE)%RIGHTARROW(1:5) = AC_DATA_INPUTS(IACT)%RIGHTARROW(PHASE, 1:5)
      DO IAP = 1, 5
        AC_TEMP(IACT)%PHASE(PHASE)%LEFTARROW(IAP) = AC_DATA_INPUTS(IACT)%LEFTARROW(PHASE, IAP)
        AC_TEMP(IACT)%PHASE(PHASE)%THRUARROW(IAP) = AC_DATA_INPUTS(IACT)%THRUARROW(PHASE, IAP)
        AC_TEMP(IACT)%PHASE(PHASE)%RIGHTARROW(IAP) = AC_DATA_INPUTS(IACT)%RIGHTARROW(PHASE, IAP)
        AC_TEMP(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
        AC_TEMP(IACT)%PHASE(PHASE)%RDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
        IF(AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP) .GE. 0) THEN
          AC_TEMP(IACT)%PHASE(PHASE)%RDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
        ELSE
          AC_TEMP(IACT)%PHASE(PHASE)%LDIAGARROW(IAP) = AC_DATA_INPUTS(IACT)%DIAGARROW(PHASE, IAP)
        ENDIF
      ENDDO
    ENDDO
    ACSIGNAL_DATA(IACT, TIME_PERIOD) = AC_TEMP(IACT)
  ENDDO
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_RAMPMETERS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE RAMP_METERS
  USE SIMPARAMS
  USE API_DATA
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_RAMPMETERS = N
    CALL ALLOCATE_RAMPMETER_ARRAYS
    ALLOCATE(METER_HEADWAY1(N, N_PERIODS))
    ALLOCATE(METER_ONSET(N, N_PERIODS))
    ALLOCATE(METER_TWOPERGREEN(N, N_PERIODS))
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_RAMPMETERS[DLLEXPORT, STDCALL](RAMPMETERDATA) RESULT(ERRORS)
  USE API_DATA
  USE RAMP_METERS
  USE FREEWAY_LINKS
  USE FREEWAY_DETECTORS
  USE SIMPARAMS
  USE CTEXT
  IMPLICIT NONE
  TYPE(RAMPMETER_DATA) :: RAMPMETERDATA(NUMBER_OF_RAMPMETERS)
  INTEGER :: I, IL, N, IDET
  LOGICAL :: FOUND
! ----------------------------------------------------------------------
  ERRORS = 0
  IF(TIME_PERIOD .LE. 1) THEN
    DO I = 1, NUMBER_OF_RAMPMETERS
      METER_ONSET(I, 1) = RAMPMETERDATA(I)%ONSET
      METER_HEADWAY1(I, 1) = RAMPMETERDATA(I)%HEADWAY(1)
      RAMPMETERS(I)%DSN = RAMPMETERDATA(I)%DSN
      FOUND = .FALSE.
      DO IL = 1, N_FREEWAY_LINKS
        IF(FDSN(IL) .EQ. RAMPMETERDATA(I)%DSN .AND. LINKTYPE(IL) .GT. 0) THEN
          RAMPMETER(IL) = I
          RAMPMETERS(I)%LINK = IL
          FOUND = .TRUE.
          EXIT
        ENDIF
      ENDDO
      IF(.NOT. FOUND) THEN
        ERRORS = 1
        EXIT
      ELSE
        RAMPMETERS(I)%CONTROL = RAMPMETERDATA(I)%CONTROL
        RAMPMETERS(I)%ONSET = RAMPMETERDATA(I)%ONSET
        RAMPMETERS(I)%CAPACITY = RAMPMETERDATA(I)%CAPACITY
        RAMPMETERS(I)%SPEED = RAMPMETERDATA(I)%SPEED
        RAMPMETERS(I)%UPDINT = RAMPMETERDATA(I)%UPDINT
        RAMPMETERS(I)%STATE = MS_INACTIVE
        DO N = 1, 6
          RAMPMETERS(I)%HEADWAY(N) = RAMPMETERDATA(I)%HEADWAY(N)
        ENDDO
        DO N = 1, 10
          IF(RAMPMETERDATA(I)%DETECTOR(N) .NE. 0) THEN
            FOUND = .FALSE.
            DO IDET = 1, N_FREEWAY_DETECTORS
              IF(FDETECTOR(IDET)%LINK .NE. 0) THEN
                FOUND = .TRUE.
                EXIT
              ENDIF
            ENDDO
          ENDIF
          IF(.NOT. FOUND) THEN
            ERRORS = ERRORS + 1
            ERROR_COUNT = ERROR_COUNT + 1
            WRITE(MSGTEXT, '(A, I5)') 'DETECTOR NOT FOUND FOR RAMPMETER AT NODE ', RAMPMETERDATA(I)%DSN
            CALL SENDTEXTMSG(M_ERROR)
            WRITE(MSGTEXT, '(A, I5)') '  DETECTOR NUMBER = ', RAMPMETERDATA(I)%DETECTOR(N)
            CALL SENDTEXTMSG(M_ERROR)
          ENDIF
        ENDDO
        RAMPMETERS(I)%DETECTOR = RAMPMETERDATA(I)%DETECTOR
        RAMPMETERS(I)%TWO_PERGREEN = RAMPMETERDATA(I)%TWOPERGREEN
        METER_HEADWAY1(I, 1) = RAMPMETERDATA(I)%HEADWAY(1)
        METER_ONSET(I, 1) = RAMPMETERDATA(I)%ONSET
        METER_TWOPERGREEN(I, 1) = RAMPMETERS(I)%TWO_PERGREEN
      ENDIF
    ENDDO
  ELSE
    DO I = 1, NUMBER_OF_RAMPMETERS
      DO N = 1, 6
        IF(RAMPMETERS(I)%HEADWAY(N) .NE. RAMPMETERDATA(I)%HEADWAY(N)) THEN
          WRITE37(I, TIME_PERIOD) = .TRUE.
        ELSEIF(RAMPMETERDATA(I)%ONSET .NE. 0) THEN
          WRITE37(I, TIME_PERIOD) = .TRUE.
        ELSEIF(RAMPMETERS(I)%TWO_PERGREEN .NE. RAMPMETERDATA(I)%TWOPERGREEN) THEN
          WRITE37(I, TIME_PERIOD) = .TRUE.
        ENDIF
        IF(WRITE37(I, TIME_PERIOD)) THEN
          METER_HEADWAY1(I, TIME_PERIOD) = RAMPMETERDATA(I)%HEADWAY(1)
          METER_ONSET(I, TIME_PERIOD) = RAMPMETERDATA(I)%ONSET
          METER_TWOPERGREEN(I, TIME_PERIOD) = RAMPMETERS(I)%TWO_PERGREEN
          RAMPMETERS(I)%HEADWAY(N) = RAMPMETERDATA(I)%HEADWAY(N)
          RAMPMETERS(I)%ONSET = RAMPMETERDATA(I)%ONSET
          RAMPMETERS(I)%TWO_PERGREEN = RAMPMETERDATA(I)%TWOPERGREEN
        ENDIF
        IF(RAMPMETERS(I)%CONTROL .EQ. 1) EXIT
      ENDDO
    ENDDO
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_FREEWAY_DETECTORS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE FREEWAY_DETECTORS
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    N_FREEWAY_DETECTORS = N
    CALL ALLOCATE_FREEWAY_DETECTOR_ARRAYS
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_FREEWAY_DETECTORS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE FREEWAY_DETECTORS
  USE FREEWAY_LINKS
  IMPLICIT NONE
  TYPE(API_DETECTOR_DATA) :: INPUTS(N_FREEWAY_DETECTORS)
  INTEGER :: I, USN, DSN, IL, IDET, NDET
! ----------------------------------------------------------------------
  ERRORS = 0
  DO I = 1, N_FREEWAY_DETECTORS
    USN = INPUTS(I)%USN
    DSN = INPUTS(I)%DSN
    CALL FIND_FREEWAY_LINK(USN, DSN, IL)
    IF(IL .NE. 0) THEN
      IF(FFIRST_DETECTOR(IL) .EQ. 0) THEN
        FFIRST_DETECTOR(IL) = I
      ELSE
        IDET = FFIRST_DETECTOR(IL)
        DO WHILE(IDET .NE. 0)
          NDET = IDET            
          IDET = FDETECTOR(NDET)%NEXT_DET
        ENDDO
        FDETECTOR(NDET)%NEXT_DET = I
      ENDIF
      FDETECTOR(I)%LINK = IL
      FDETECTOR(I)%LANE1 = INPUTS(I)%LANE1
      FDETECTOR(I)%LANE2 = INPUTS(I)%LANE2
      FDETECTOR(I)%LOCATION = INPUTS(I)%LOCATION
      FDETECTOR(I)%CARRYOVER_TIME = INPUTS(I)%CARRYOVER_TIME
      FDETECTOR(I)%DELAY_TIME = INPUTS(I)%DELAY_TIME
      FDETECTOR(I)%TYPE_CODE = INPUTS(I)%TYPE_CODE
      FDETECTOR(I)%STATION_ID = INPUTS(I)%STATION_ID
      FDETECTOR(I)%ZONE_LENGTH = INPUTS(I)%ZONE_LENGTH
      FDETECTOR(I)%OPERATION_CODE = INPUTS(I)%OPERATION_CODE
    ENDIF
  ENDDO
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_BUSROUTES[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE BUS_ROUTE_DATA
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_ROUTES = N
    CALL ALLOCATE_BUS_ROUTE_DATA_ARRAYS
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_BUSROUTES[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE BUS_ROUTE_DATA
  USE NODE_TABLE
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE GLOBAL_DATA
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(BUSR) :: INPUTS(NUMBER_OF_ROUTES)
  INTEGER :: I, NR, IL, INODE, LAST
  LOGICAL :: FOUND
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    DO I = 1, NUMBER_OF_ROUTES
      NR = INPUTS(I)%NUMBER
      BUSR_HDWY(NR) = INPUTS(I)%HDWY
      BUSR_OFFSET(NR) = INPUTS(I)%OFFSET
      BUSR_NNODES(NR) = INPUTS(I)%NNODES + 2
      FOUND = .FALSE.
      DO IL = 1, N_FREEWAY_LINKS
        IF(FUSN(IL) .GE. 8000 .AND. FDSN(IL) .EQ. INPUTS(I)%ROUTE_NODES(1)) THEN
          FOUND = .TRUE.
          BUSR_ROUTE_NODES(NR, 1) = FUSN(IL)
          EXIT
        ENDIF
      ENDDO
      IF(.NOT. FOUND) THEN
        DO IL = 1, N_STREET_LINKS
          IF(SUSN(IL) .GE. 8000 .AND. SDSN(IL) .EQ. INPUTS(I)%ROUTE_NODES(1)) THEN
            FOUND = .TRUE.
            BUSR_ROUTE_NODES(NR, 1) = SUSN(IL)
            EXIT
          ENDIF
        ENDDO
      ENDIF
      DO INODE = 1, INPUTS(I)%NNODES
        BUSR_ROUTE_NODES(NR, INODE+1) = INPUTS(I)%ROUTE_NODES(INODE)
      ENDDO
      LAST = INPUTS(I)%ROUTE_NODES(INPUTS(I)%NNODES)
      IF(NETCODE(LAST) .EQ. I_FREEWAY) THEN
        DO IL = 1, N_FREEWAY_LINKS
          IF(FDSN(IL) .GE. 8000 .AND. FUSN(IL) .EQ. INPUTS(I)%ROUTE_NODES(LAST)) THEN
            BUSR_ROUTE_NODES(NR, BUSR_NNODES(NR)) = FDSN(IL)
            EXIT
          ENDIF
        ENDDO
      ELSE
        DO IL = 1, N_STREET_LINKS
          IF(SDSN(IL) .GE. 8000 .AND. SUSN(IL) .EQ. LAST) THEN
            BUSR_ROUTE_NODES(NR, BUSR_NNODES(NR)) = SDSN(IL)
            EXIT
          ENDIF
        ENDDO
      ENDIF
      BUSR_STATIONLIST(NR, 1:100) = INPUTS(I)%STATIONLIST
    ENDDO
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_BUSSTATIONS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE BUS_STATION_DATA
  USE STREET_LINKS
  USE SIMPARAMS
  USE CTEXT
  IMPLICIT NONE
  TYPE(BUSS_DATA) :: INPUTS(99)
  INTEGER :: NS, IL, ISTAT, I
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    ALLOCATE(BUS_STATION_LIST(99))
    IF(SUM(DWELL_MULTIPLIER) .EQ. 0.0) CALL DEFINE_DWELL_MULTIPLIERS
    DO NS = 1, 99
      IF(INPUTS(NS)%USN .EQ. 0 .AND. INPUTS(NS)%DSN .EQ. 0) CYCLE
      BUS_STATION_LIST(NS)%BLOCK_CODE = INPUTS(NS)%BLOCK_CODE
      CALL FIND_STREET_LINK(INPUTS(NS)%USN, INPUTS(NS)%DSN, IL)
      IF(IL .EQ. 0) THEN
        ERRORS = ERRORS + 1
        ERROR_COUNT = ERROR_COUNT + 1
        WRITE(MSGTEXT, '(A, I4)') 'LINK NOT FOUND FOR BUS STATION ', NS
        CALL SENDTEXTMSG(M_ERROR)
        WRITE(MSGTEXT, '(A, 2I5)') '  LINK = ', INPUTS(NS)%USN, INPUTS(NS)%DSN
        CALL SENDTEXTMSG(M_ERROR)
      ELSE
        BUS_STATION_LIST(NS)%LINK = IL
        BUS_STATION_LIST(NS)%POCKET_LANE = 0
        BUS_STATION_LIST(NS)%LOCATION = INPUTS(NS)%LOCATION
        IF(SLENGTH(IL) - BUS_STATION_LIST(NS)%LOCATION .LE. 50 .AND. NS .LT. 64) THEN
          NUMBER_RIGHTPOCKETS(IL) = 1
          BUS_STATION_LIST(NS)%POCKET_LANE = 7 - NUMBER_LEFTPOCKETS(IL)
        ENDIF
        BUS_STATION_LIST(NS)%CAPACITY = INPUTS(NS)%CAPACITY
        BUS_STATION_LIST(NS)%TYPE_CODE = INPUTS(NS)%TYPE_CODE
        IF(FIRST_BUS_STATION(IL) .EQ. 0) THEN
          FIRST_BUS_STATION(IL) = NS
        ELSE
          ISTAT = FIRST_BUS_STATION(IL)
          DO WHILE(ISTAT .NE. 0)
            I = ISTAT
            ISTAT = BUS_STATION_LIST(NS)%NEXT_STATION
          ENDDO
          BUS_STATION_LIST(I)%NEXT_STATION = NS
        ENDIF
      ENDIF
      BUS_STATION_LIST(NS)%DWELL = INPUTS(NS)%DWELL
      BUS_STATION_LIST(NS)%BYPASS_PCT = INPUTS(NS)%BYPASS_PCT / 100.
    ENDDO
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_STREET_DETECTORS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE STREET_DETECTORS
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    N_STREET_DETECTORS = N
    CALL ALLOCATE_STREET_DETECTOR_ARRAYS
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_STREET_DETECTORS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE ACTUATED_CONTROLLERS
  USE STREET_DETECTORS
  USE STREET_LINKS
  IMPLICIT NONE
  TYPE(API_DETECTOR_DATA) :: INPUTS(N_STREET_DETECTORS)
  INTEGER :: I, USN, DSN, IL, IDET, NDET, NCOUNT, ISIG
! ----------------------------------------------------------------------
  ERRORS = 0
  DO I = 1, N_STREET_DETECTORS
    USN = INPUTS(I)%USN
    DSN = INPUTS(I)%DSN
    CALL FIND_STREET_LINK(USN, DSN, IL)
    IF(IL .NE. 0) THEN
      IF(SFIRST_DETECTOR(IL) .EQ. 0) THEN
        SFIRST_DETECTOR(IL) = I
      ELSE
        IDET = SFIRST_DETECTOR(IL)
        DO WHILE(IDET .NE. 0)
          NDET = IDET            
          IDET = SDETECTOR(NDET)%NEXT_DET
        ENDDO
        SDETECTOR(NDET)%NEXT_DET = I
      ENDIF
      SDETECTOR(I)%LINK = IL
      SDETECTOR(I)%LANE1 = INPUTS(I)%LANE1
      SDETECTOR(I)%LANE2 = INPUTS(I)%LANE2
      SDETECTOR(I)%LOCATION = INPUTS(I)%LOCATION
      SDETECTOR(I)%CARRYOVER_TIME = INPUTS(I)%CARRYOVER_TIME
      SDETECTOR(I)%DELAY_TIME = INPUTS(I)%DELAY_TIME
      SDETECTOR(I)%TYPE_CODE = INPUTS(I)%TYPE_CODE
      SDETECTOR(I)%STATION_ID = INPUTS(I)%STATION_ID
      SDETECTOR(I)%ZONE_LENGTH = INPUTS(I)%ZONE_LENGTH
      SDETECTOR(I)%OPERATION_CODE = INPUTS(I)%OPERATION_CODE
      SDETECTOR(I)%ASSOCIATED_PHASE = INPUTS(I)%ASSOCIATED_PHASE
      
      DO ISIG = 1, NUMBER_OF_ACS
        IF(AC_SIGNALS(ISIG)%NODE .EQ. DSN) THEN
          NCOUNT = AC_SIGNALS(ISIG)%SDP%DETECTOR_COUNT + 1
          AC_SIGNALS(ISIG)%SDP%DETECTOR_COUNT = NCOUNT
          AC_SIGNALS(ISIG)%SDP%DETECTOR_LIST(NCOUNT) = I
        ENDIF
      ENDDO
    ENDIF
  ENDDO
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_EVENTS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE EVENTS
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_EVENTS = N
    CALL ALLOCATE_EVENT_ARRAYS
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_EVENTS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE EVENTS
  IMPLICIT NONE
  TYPE(EVENT_DATA) :: INPUTS(NUMBER_OF_EVENTS)
  INTEGER :: I
! ----------------------------------------------------------------------
  ERRORS = 0
  DO I = 1, NUMBER_OF_EVENTS
    BLOCKAGE_BEGIN_TIME(I) = INPUTS(I)%BEGIN_TIME
    BLOCKAGE_END_TIME(I) = INPUTS(I)%END_TIME
    BLOCKAGE_LANE(I) = INPUTS(I)%LANE
    BLOCKAGE_LINK(I) = INPUTS(I)%LINK
    BLOCKAGE_LOCATION(I) = INPUTS(I)%LOCATION
    BLOCKAGE_TYPE(I) = INPUTS(I)%TYPE
  ENDDO
  END
  
! ==================================================================================================
  INTEGER FUNCTION ADD_EVENT[DLLEXPORT, STDCALL](EVENT) RESULT(ERRORS)
  USE API_DATA
  USE EVENTS
  IMPLICIT NONE
  TYPE(EVENT_DATA) :: EVENT
! ----------------------------------------------------------------------
  ERRORS = 0
  IF(NUMBER_OF_EVENTS .EQ. 0) THEN
    NUMBER_OF_EVENTS = 1
    CALL ALLOCATE_EVENT_ARRAYS
  ELSE
    CALL REALLOCATE_EVENT_ARRAYS
  ENDIF          
  BLOCKAGE_BEGIN_TIME(NUMBER_OF_EVENTS) = EVENT%BEGIN_TIME
  BLOCKAGE_END_TIME(NUMBER_OF_EVENTS) = EVENT%END_TIME
  BLOCKAGE_LANE(NUMBER_OF_EVENTS) = EVENT%LANE
  BLOCKAGE_LINK(NUMBER_OF_EVENTS) = EVENT%LINK
  BLOCKAGE_LOCATION(NUMBER_OF_EVENTS) = EVENT%LOCATION
  BLOCKAGE_TYPE(NUMBER_OF_EVENTS) = EVENT%TYPE
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_PARKING_ZONES[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE PARKING
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_PARKING_ZONES = N
    CALL ALLOCATE_PARKING_ARRAYS
    IF(N .GT. 1) CALL REALLOCATE_PARKING_ARRAYS
    ALLOCATE(WRITE56(N, N_PERIODS))
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_PARKING_ZONES[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE PARKING
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(PARKING_DATA) :: INPUTS(NUMBER_OF_PARKING_ZONES)
  INTEGER :: I
! ----------------------------------------------------------------------
  ERRORS = 0
  IF(TIME_PERIOD .GT. 1) WRITE56 = .TRUE.
  DO I = 1, NUMBER_OF_PARKING_ZONES
    PARK_DURATION(I) = INPUTS(I)%DURATION
    PARK_FREQ(I) = INPUTS(I)%FREQ
    PARK_LEFT_START(I) = INPUTS(I)%LEFT_START
    PARK_LEFT_LEN(I) = INPUTS(I)%LEFT_LEN
    PARK_RIGHT_START(I) = INPUTS(I)%RIGHT_START
    PARK_RIGHT_LEN(I) = INPUTS(I)%RIGHT_LEN
    PARKING_ZONE_LINK(I) = INPUTS(I)%LINK
  ENDDO
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_INCIDENTS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE INCIDENTS
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_INCIDENTS = N
    CALL ALLOCATE_INCIDENT_ARRAYS
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_INCIDENTS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE INCIDENTS
  USE SIMPARAMS
  USE CTEXT
  IMPLICIT NONE
  TYPE(INCIDENT_DATA) :: INPUTS(NUMBER_OF_INCIDENTS)
  INTEGER :: I, INCTYP, DURATION, ILENGTH
! ----------------------------------------------------------------------
  ERRORS = 0
  DO I = 1, NUMBER_OF_INCIDENTS
    IF(INPUTS(I)%LINK .EQ. 0) THEN
      ERRORS = ERRORS + 1
      ERROR_COUNT = ERROR_COUNT + 1
      WRITE(MSGTEXT, '(A, I4)') 'LINK NOT SPECIFIED FOR INCIDENT NUMBER ', I
      CALL SENDTEXTMSG(M_ERROR)
    ELSE
      INCIDENT_LINK(I) = INPUTS(I)%LINK
      INCIDENT_BEGIN_POINT(I) = INPUTS(I)%BEGIN_POINT
      INCIDENT_BEGIN_TIME(I) = INPUTS(I)%BEGIN_TIME
      INCIDENT_END_POINT(I) = INPUTS(I)%END_POINT
      INCIDENT_END_TIME(I) = INPUTS(I)%END_TIME
      INCIDENT_RBNF(I) = INPUTS(I)%RBNF
      INCIDENT_WARN_POINT(I) = INPUTS(I)%WARN_POINT
      INCIDENT_CODE(I, 1:11) = INPUTS(I)%CODE
      INCTYP = 1                                  
      DURATION = INPUTS(I)%END_TIME - INPUTS(I)%BEGIN_TIME
      ILENGTH = INPUTS(I)%END_POINT - INPUTS(I)%BEGIN_POINT
#if _TSIS_COMPATIBLE    
      CALL ADDFREEWAYEVENT(INPUTS(I)%LINK, INPUTS(I)%BEGIN_TIME, DURATION, INCTYP,  &
          INPUTS(I)%CODE, INPUTS(I)%BEGIN_POINT, ILENGTH, INPUTS(I)%WARN_POINT, INPUTS(I)%RBNF)
#endif    
    ENDIF
  ENDDO
  END
  
! ==================================================================================================
  INTEGER FUNCTION DEFINE_NODE_COORDINATES[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE NODE_TABLE
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(NODE_LOCATION_DATA) :: INPUTS(8999)
  INTEGER :: I
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    DO I = 1, 8999
      X195(I) = INPUTS(I)%X
      Y195(I) = INPUTS(I)%Y
      NODE_LAT(I) = INPUTS(I)%LATITUDE
      NODE_LON(I) = INPUTS(I)%LONGITUDE
      NODE_ELEV(I) = INPUTS(I)%ELEVATION
      IS_DEFINED(I) = INPUTS(I)%IS_DEFINED
    ENDDO
  ELSE
    ERRORS = 1
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION DEFINE_VEHICLE_TYPES[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE VEHICLE_TYPES
  USE SIMPARAMS
  IMPLICIT NONE
  TYPE(VEHICLE_TYPE_DATA) :: INPUTS(NTYPES)
  INTEGER :: I
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    DO I = 1, NTYPES
      VTLENGTH(I) = INPUTS(I)%LENGTH
      HDWY_FACTOR(I) = INPUTS(I)%HEADWAY_FACTOR
      AVG_OCCS(I) = INPUTS(I)%AVERAGE_OCCUPANCY
      NEMDEC(I) = INPUTS(I)%EMERGENCY_DECEL
      FLT_FREEWAY_AUTO(I) = INPUTS(I)%FLEET_FREEWAY_AUTO
      FLT_FREEWAY_TRUCK(I) = INPUTS(I)%FLEET_FREEWAY_TRUCK
      FLT_FREEWAY_CARPOOL(I) = INPUTS(I)%FLEET_FREEWAY_CARPOOL
      FLT_FREEWAY_BUS(I) = INPUTS(I)%FLEET_FREEWAY_BUS
      FLT_FREEWAY_EV(I) = INPUTS(I)%FLEET_FREEWAY_EV
      FLT_STREET_AUTO(I) = INPUTS(I)%FLEET_STREET_AUTO
      FLT_STREET_TRUCK(I) = INPUTS(I)%FLEET_STREET_TRUCK
      FLT_STREET_CARPOOL(I) = INPUTS(I)%FLEET_STREET_CARPOOL
      FLT_STREET_BUS(I) = INPUTS(I)%FLEET_STREET_BUS
      FLT_STREET_EV(I) = INPUTS(I)%FLEET_STREET_EV
      FLT_STREET_BIKE(I) = INPUTS(I)%FLEET_STREET_BIKE 
    ENDDO
  ELSE
    ERRORS = 1
  ENDIF
  END
  
! ==================================================================================================
  INTEGER FUNCTION SET_NUMBER_OF_DIVERSIONS[DLLEXPORT, STDCALL](N) RESULT(ERRORS)
  USE DIVERSIONS
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N
! ----------------------------------------------------------------------
  IF(TIME_PERIOD .LE. 1) THEN
    ERRORS = 0
    NUMBER_OF_DIVERSIONS = N
    CALL ALLOCATE_DIVERSION_ARRAYS
  ELSE
    ERRORS = 1
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION DEFINE_DIVERSIONS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE DIVERSIONS
  IMPLICIT NONE
  TYPE(DIVERSION_DATA) :: INPUTS(NUMBER_OF_DIVERSIONS)
  INTEGER :: I
! ----------------------------------------------------------------------
  ERRORS = 0
  DO I = 1, NUMBER_OF_DIVERSIONS
    DIVERSION_BEGIN_TIME(I) = INPUTS(I)%BEGIN_TIME
    DIVERSION_END_TIME(I) = INPUTS(I)%END_TIME
    DIVERSION_LINK(I) = INPUTS(I)%LINK
    DIVERSION_LOCATION(I) = INPUTS(I)%LOCATION
    DIVERSION_PATHID(I) = INPUTS(I)%PATHID
    DIVERSION_PERCENTAGE(I) = INPUTS(I)%PERCENTAGE
    DIVERSION_SPEED(I) = INPUTS(I)%SPEED
  ENDDO
  END  

! ==================================================================================================
  INTEGER FUNCTION DEFINE_CONDITIONAL_TURNPCTS[DLLEXPORT, STDCALL](INPUTS) RESULT(ERRORS)
  USE API_DATA
  USE STREET_LINKS
  USE SIMPARAMS
  USE CTEXT
  IMPLICIT NONE
  TYPE(COND_TURNPCTS) :: INPUTS
  INTEGER :: IL
! ----------------------------------------------------------------------
  ERRORS = 0
  IF(INPUTS%DSN .GE. 8000) THEN
    ERRORS = ERRORS + 1
    ERROR_COUNT = ERROR_COUNT + 1
    WRITE(MSGTEXT, '(A, 2I4)') 'CONDITIONAL TURN PERCENTAGES ENTERED FOR AN EXIT LINK ', INPUTS%USN, INPUTS%DSN
    CALL SENDTEXTMSG(M_ERROR)
  ELSE
    CALL FIND_STREET_LINK(INPUTS%USN, INPUTS%DSN, IL)
    IF(IL .NE. 0) THEN
      IF(SUM(INPUTS%LEFTPCT) .NE. 0) THEN
        COND_LEFT(IL) = .TRUE.
        COND_LEFTPCT(IL, 1) = INPUTS%LEFTPCT(1)
        COND_LEFTPCT(IL, 2) = INPUTS%LEFTPCT(2)
        COND_LEFTPCT(IL, 3) = INPUTS%LEFTPCT(3)
        COND_LEFTPCT(IL, 4) = INPUTS%LEFTPCT(4)
      ENDIF
      IF(SUM(INPUTS%THRUPCT) .NE. 0) THEN
        COND_THRU(IL) = .TRUE.
        COND_THRUPCT(IL, 1) = INPUTS%THRUPCT(1)
        COND_THRUPCT(IL, 2) = INPUTS%THRUPCT(2)
        COND_THRUPCT(IL, 3) = INPUTS%THRUPCT(3)
        COND_THRUPCT(IL, 4) = INPUTS%THRUPCT(4)
      ENDIF
      IF(SUM(INPUTS%RIGHTPCT) .NE. 0) THEN
        COND_RIGHT(IL) = .TRUE.
        COND_RIGHTPCT(IL, 1) = INPUTS%RIGHTPCT(1)
        COND_RIGHTPCT(IL, 2) = INPUTS%RIGHTPCT(2)
        COND_RIGHTPCT(IL, 3) = INPUTS%RIGHTPCT(3)
        COND_RIGHTPCT(IL, 4) = INPUTS%RIGHTPCT(4)
      ENDIF
      IF(SUM(INPUTS%DIAGPCT) .NE. 0) THEN
        COND_DIAG(IL) = .TRUE.
        COND_DIAGPCT(IL, 1) = INPUTS%DIAGPCT(1)
        COND_DIAGPCT(IL, 2) = INPUTS%DIAGPCT(2)
        COND_DIAGPCT(IL, 3) = INPUTS%DIAGPCT(3)
        COND_DIAGPCT(IL, 4) = INPUTS%DIAGPCT(4)
      ENDIF
    ENDIF
  ENDIF
  END
  
#endif  

  SUBROUTINE GET_NEXT_8000ID(INODE)
  USE NODE_TABLE
  IMPLICIT NONE
  INTEGER, INTENT(OUT) :: INODE
  INTEGER :: I
! ----------------------------------------------------------------------
  DO I = 8000, 8999
    IF(IS_USED(I)) CYCLE
    INODE = I
    IS_USED(I) = .TRUE.
    EXIT
  ENDDO
  RETURN
  END
  
