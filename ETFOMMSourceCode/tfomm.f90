! Copyright © 2014
! New Global Systems for Intelligent Transportation Management Corp.
  
! This file is part of ETFOMM.
!
! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU Affero General Public License as
! published by the Free Software Foundation, either version 3 of the
! License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU Affero General Public License for more details.
!
! You should have received a copy of the GNU Affero General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

  
! --- These functions are called by TSHELL to perform the simulation.

! ==================================================================================================
  INTEGER FUNCTION STARTUP[DLLEXPORT, STDCALL]()
!
!     return values
!         0 - no errors
!         1 - failure opening files
!         3 - errors in input
!

  USE SIMPARAMS
  USE TEXT
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE INCIDENTS
  USE GLOBAL_DATA
  USE FREEWAY_VEHICLES
  USE STREET_VEHICLES
  USE NODE_TABLE
  USE ENTRYNODE_DATA
  IMPLICIT NONE
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
#endif    
  INCLUDE 'VERSION.FI'
! ----------------------------------------------------------------------
  SIMTIME = 0.0
  ERROR_COUNT = 0
  WRITE_MOES = .TRUE. !Always write out the MOEs
  WTRF = .FALSE.
  READING_TRF = .TRUE.
  
! --- START THE CPU TIMER.

  CALL CPU_TIME(START_CPU)

  WRITE(MSGTEXT, '(A, A, A)') '---------------- ETFOMM VERSION ', KVER, ' ----------------'
  CALL SENDTEXTMSG(M_INFO)
  MSGTEXT = ''
  CALL SENDTEXTMSG(M_INFO)
  
  PRIOR_CPU = START_CPU
  START_TIMER = SECNDS(0.0)
  TIME_PERIOD = 1
  LAST_ID_USED = 0
  HIGHEST_INDEX_F = 1
  HIGHEST_INDEX_S = 1
  SORTED_LIST_LENGTH = 0
  CALL ALLOCATE_NODE_ARRAYS(MAX_NODE_NUMBER + 1000)
  CALL ALLOCATE_ENTRYNODE_DATA
  CALL INIT_QUEUES
 
! --- Read the input records.
 
  CALL GET_NETWORK_DATA
  IF(N_FREEWAY_LINKS .GT. 0 .AND. N_STREET_LINKS .GT. 0) THEN
    CALL ALLOCATE_FREEWAY_INTERFACE_ARRAYS
    CALL ALLOCATE_STREET_INTERFACE_ARRAYS
  ENDIF

#ifdef DebugVersion
#ifndef TSIS_COMPATIBLE
  type_of_run = 1!temporary used for testing
#endif
#endif

  IF(TYPE_OF_RUN .EQ. 4) THEN
#ifdef TSIS_COMPATIBLE
    WRITE(MSGTEXT, '(A)') ''
    CALL SENDTEXTMSG(M_INFO)
    WRITE(MSGTEXT, '(A)') 'Reading simulation results from animation text files...'
    CALL SENDTEXTMSG(M_INFO)
    WRITE(MSGTEXT, '(A)') ''
    CALL SENDTEXTMSG(M_INFO)
    CALL GENERATE_ANIMATION_FILES
    STARTUP = 0
    RETURN
#else    
    WRITE(MSGTEXT, '(A)') '  TYPE_OF_RUN = 4 NOT SUPPORTED BY ETFOMM64'
    CALL SENDTEXTMSG(M_ERROR)
    STARTUP = 3
    RETURN
#endif
  ELSE
    
    STARTUP = 0
 
! --- Read the time-varying input records and store data for the Trip Generator.
 
    IF(ERROR_FLAG .EQ. 0 .AND. ERROR_COUNT .EQ. 0) CALL READ_TIME_VARYING_INPUT
 
    IF(TYPE_OF_RUN .EQ. 1 .OR. TYPE_OF_RUN .EQ. -1) THEN
      CALL CHECK_INPUTS
      MSGTEXT = ''
      CALL SENDTEXTMSG(M_INFO)
      IF(ERROR_COUNT .EQ. 0) THEN
        WRITE(MSGTEXT, '(A)') '  NO ERRORS WERE FOUND'
        CALL SENDTEXTMSG(M_INFO)
      ELSEIF(ERROR_COUNT .EQ. 1) THEN
        WRITE(MSGTEXT, '(A, I4, A)') '**** FOUND 1 ERROR ****'
        CALL SENDTEXTMSG(M_ERROR)
      ELSE
        WRITE(MSGTEXT, '(A, I4, A)') '**** FOUND ', ERROR_COUNT, ' ERRORS ****'
        CALL SENDTEXTMSG(M_ERROR)
      ENDIF
      MSGTEXT = ''
      CALL SENDTEXTMSG(M_INFO)
    ENDIF
 
    IF(ERROR_FLAG .EQ. 0 .AND. ERROR_COUNT .EQ. 0) THEN
      STARTUP = 0
      IF(N_FREEWAY_LINKS .GT. 0) THEN
        CALL ORGANIZE_FREEWAY_LINKS
        CALL ALLOCATE_FREEWAY_VEHICLE_ARRAYS
      ENDIF
      IF(N_STREET_LINKS .GT. 0) THEN
        CALL ALLOCATE_STREET_VEHICLE_ARRAYS
      ENDIF
      IF(ERROR_FLAG .NE. 0 .OR. ERROR_COUNT .NE. 0) THEN
        STARTUP = 3
        CALL CPU_TIME(PRIOR_CPU)
      ENDIF
    ELSE
      STARTUP = 3
      CALL CPU_TIME(PRIOR_CPU)
    ENDIF
#ifdef TSIS_COMPATIBLE
    CALL SIMCALLRTE(RT_INITIALIZE)
#endif
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION RUNTOEQUILIBRIUM[DLLEXPORT, STDCALL]()
!
!     return values
!         0 - no errors
!         1 - errors
!         2 - simulation aborted by user
!
  USE SIMPARAMS
  USE TEXT
  IMPLICIT NONE
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
#endif    
  INTEGER :: NSTEPS = 0
! ----------------------------------------------------------------------
  RUNTOEQUILIBRIUM = 0
  IF((TYPE_OF_RUN .EQ. 0 .OR. TYPE_OF_RUN .EQ. 1) .AND. .NOT. SKIP_INIT) THEN
    INITMODE = .TRUE.
    SIMTIME = 0.
    CALL GET_PBV_INPUTS
 
  ! --- Run the initialization phase for the requested time.
 
    DO WHILE(SIMTIME .LE. INITIALIZATION_END)
 
  ! --- Call the Trip Generator once every 60 seconds to place vehicles
  ! --- in the entry queues.
 
      IF(MOD(SIMTIME, 60.) .LT. TIMESTEP/2) CALL TRIPGENERATOR
 
  ! --- Check the entry queues every time step and inject vehicles into the network
  ! --- as scheduled. Also check for delayed vehicles in the queue.
 
      CALL CHECK_ENTRY_QUEUES
      CALL CHECK_PBV_QUEUE
      CALL CHECK_BUS_ROUTES
      CALL CHECK_BUS_QUEUES
      CALL STEP_SIMULATION(NSTEPS)
#ifdef TSIS_COMPATIBLE
      CALL YIELD_TIME
#endif
      IF(ERROR_FLAG .GT. 0) THEN
        RUNTOEQUILIBRIUM = 1
      ELSEIF(EXITFLG .GT. 0) THEN
        WRITE(MSGTEXT, '(A)') 'SIMULATION ABORTED BY USER'
        CALL SENDTEXTMSG(M_INFO)
        RUNTOEQUILIBRIUM = 2
        EXIT
      ENDIF
    ENDDO
    SIMTIME = 0.
    CALL EMPTY_QUEUES
    WRITE(MSGTEXT, '(A)') 'INITIALIZATION PHASE COMPLETE'
    CALL SENDTEXTMSG(M_INFO)
  ELSE
    IF(SKIP_INIT .AND. TYPE_OF_RUN .NE. 4) THEN
      WRITE(MSGTEXT, '(A)') '    SKIPPING THE INITIALIZATION PROCESS....'
      CALL SENDTEXTMSG(M_INFO)
    ENDIF
  ENDIF
  END
! ==================================================================================================
  INTEGER FUNCTION INITIALIZE[DLLEXPORT, STDCALL]()
!
!     return values
!         0 - no errors
!         1 - errors
!         2 - simulation aborted by user
!         4 - no errors and done
!
  USE SIMPARAMS
  USE TEXT
  IMPLICIT NONE
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
#endif    
  INTEGER :: NSTEPS = 0
! ----------------------------------------------------------------------
  INITIALIZE = 0
  IF((TYPE_OF_RUN .EQ. 0 .OR. TYPE_OF_RUN .EQ. 1) .AND. .NOT. SKIP_INIT) THEN
    INITMODE = .TRUE.
    IF(SIMTIME .EQ. 0.0) CALL GET_PBV_INPUTS

  ! --- Run the initialization phase for one time step.
 
    IF(SIMTIME .LE. INITIALIZATION_END) THEN
 
  ! --- Call the Trip Generator once every 60 seconds to place vehicles
  ! --- in the entry queues.
 
      IF(MOD(SIMTIME, 60.) .LT. TIMESTEP/2) CALL TRIPGENERATOR
 
  ! --- Check the entry queues every time step and inject vehicles into the network
  ! --- as scheduled. Also check for delayed vehicles in the queue.
 
      CALL CHECK_ENTRY_QUEUES
      CALL CHECK_PBV_QUEUE
      CALL CHECK_BUS_ROUTES
      CALL CHECK_BUS_QUEUES
      CALL STEP_SIMULATION(NSTEPS)
#ifdef TSIS_COMPATIBLE
      CALL YIELD_TIME
#endif
      IF(ERROR_FLAG .GT. 0) THEN
        INITIALIZE = 1
      ELSEIF(EXITFLG .GT. 0) THEN
        WRITE(MSGTEXT, '(A)') 'SIMULATION ABORTED BY USER'
        CALL SENDTEXTMSG(M_INFO)
        INITIALIZE = 2
      ENDIF
    ENDIF
    IF(SIMTIME .GT. INITIALIZATION_END) THEN
      INITIALIZE = 4
      SIMTIME = 0.
      NSTEPS = 0
      CALL EMPTY_QUEUES
      WRITE(MSGTEXT, '(A)') 'INITIALIZATION PHASE COMPLETE'
      CALL SENDTEXTMSG(M_INFO)
    ENDIF
  ELSE
    IF(SKIP_INIT .AND. TYPE_OF_RUN .NE. 4) THEN
      INITIALIZE = 4
      WRITE(MSGTEXT, '(A)') '    SKIPPING THE INITIALIZATION PROCESS....'
      CALL SENDTEXTMSG(M_INFO)
    ELSEIF(TYPE_OF_RUN .EQ. -1) THEN
      INITIALIZE = 4
    ENDIF
  ENDIF
  END

! ==================================================================================================
  INTEGER FUNCTION SIMULATE[DLLEXPORT, STDCALL]() 
!
!     return values
!         0 - no errors but not done
!         1 - errors
!         2 - simulation aborted by user
!         4 - no errors and done
!
  USE SIMPARAMS
  USE TEXT
  USE EVENTS
  USE PARKING
  USE EV_DATA
  IMPLICIT NONE
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
#endif    
  INCLUDE 'IOFILES.INC'
  INTEGER :: FILE1 = 1, FILE2 = 2
  LOGICAL :: WSAVE_STATE = .FALSE., WREAD = .TRUE.
  COMMON /GRAPHIO/ TSTEPFILE, TINTERVALFILE
  INTEGER :: TSTEPFILE, TINTERVALFILE
  INTEGER :: NSTEPS = 0
! ----------------------------------------------------------------------
  IF(TYPE_OF_RUN .EQ. -1) THEN
    SIMULATE = 0
    IF(SIMTIME .GE. SUM(TPSECONDS(1:TIME_PERIOD))) THEN
      TIME_PERIOD = TIME_PERIOD + 1
      IF(SIMTIME .LT. SIMULATION_END) THEN
        MSGTEXT = ''
        CALL SENDTEXTMSG(M_INFO)
        WRITE(MSGTEXT, '(A, I2)') 'CHECKING FOR INPUT ERRORS FOR TIME PERIOD ', TIME_PERIOD
        CALL SENDTEXTMSG(M_INFO)
        CALL CHECK_INPUTS
        MSGTEXT = ''
        CALL SENDTEXTMSG(M_INFO)
        IF(ERROR_COUNT .EQ. 0) THEN
          WRITE(MSGTEXT, '(A)') '  NO ERRORS WERE FOUND'
          CALL SENDTEXTMSG(M_INFO)
        ELSEIF(ERROR_COUNT .EQ. 1) THEN
          WRITE(MSGTEXT, '(A, I4, A)') '**** FOUND 1 ERROR ****'
          CALL SENDTEXTMSG(M_ERROR)
        ELSE
          WRITE(MSGTEXT, '(A, I4, A)') '**** FOUND ', ERROR_COUNT, ' ERROR(S) ****'
          CALL SENDTEXTMSG(M_ERROR)
        ENDIF
        MSGTEXT = ''
        CALL SENDTEXTMSG(M_INFO)
      ELSE
        SIMULATE = 4
      ENDIF
    ENDIF
  ELSEIF(TYPE_OF_RUN .EQ. 4) THEN
    SIMULATE = 4
  ELSE
    INITMODE = .FALSE.
    IF(WEVRUN .AND. WREAD) THEN
      WREAD = .FALSE.
      CALL READ_EV_DATA
    ENDIF
 
  ! --- TSIS will call this function repeatedly until it receives the 
  ! --- 'no errors and done' return value.
 
    IF(SIMTIME .EQ. 0) THEN
#ifdef TSIS_COMPATIBLE
      CALL SIMSTATUS(SIM_BEGINSIMULATION)
      CALL SIMCALLRTE(RT_BEGINSIMULATION)
#endif
      CALL GET_PBV_INPUTS
      CALL GET_EVENT_INPUTS
 
  ! --- Process inputs for stochastic short-term events and parking.
  ! --- Long-term events are processed when reading the inputs.
 
      CALL GENERATE_STEVENTS
      CALL GENERATE_PKEVENTS
    ENDIF
 
  ! --- Call the Trip Generator once every 60 seconds to place vehicles
  ! --- in the entry queues.
 
    IF(MOD(SIMTIME, 60.) .LT. TIMESTEP/2 .AND. SIMTIME .LT. SIMULATION_END) CALL TRIPGENERATOR

  ! --- Check the entry queues every time step and inject vehicles into the network
  ! --- as scheduled.

    CALL CHECK_ENTRY_QUEUES
    CALL CHECK_PBV_QUEUE
    CALL CHECK_BUS_ROUTES
    CALL CHECK_BUS_QUEUES

  ! --- Run the simulation for one time step.

    CALL STEP_SIMULATION(NSTEPS)
    IF(SIMTIME .GE. SIMULATION_END) THEN
      SIMULATE = 4
#ifdef TSIS_COMPATIBLE
      CALL SIMSTATUS(SIM_COMPLETE)
      CALL SIMCALLRTE(RT_SIMULATION_COMPLETE)
#endif
      WRITE(MSGTEXT, '(A)') 'SIMULATION COMPLETE'
      CALL SENDTEXTMSG(M_INFO)
      IF(WRITE_MOES) CALL WRITE_ALL_MOES
    ELSEIF(ERROR_FLAG .GT. 0) THEN
      SIMULATE = 1
    ELSEIF(EXITFLG .GT. 0) THEN
      WRITE(MSGTEXT, '(A)') 'SIMULATION ABORTED BY USER'
      CALL SENDTEXTMSG(M_INFO)
      SIMULATE = 2
    ELSE
      SIMULATE = 0
    ENDIF
    IF(WSAVE_STATE) THEN
      OPEN(FILE1, FILE = LINFNAME(1:IROOT)//'SAVE1', FORM='BINARY', ERR=10, IOMSG=ETEXT)
      OPEN(FILE2, FILE = LINFNAME(1:IROOT)//'SAVE2', FORM='BINARY', ERR=10, IOMSG=ETEXT)
      CALL SAVE_SIMULATION_DATA(FILE1, FILE2)
      CLOSE(FILE1)
      CLOSE(FILE2)
    ENDIF
#ifdef TSIS_COMPATIBLE
    CALL YIELD_TIME
#endif
  ENDIF
  RETURN
10 WRITE(MSGTEXT, '(A)') 'FILE OPEN ERROR : SIMULATE'
  CALL SENDTEXTMSG(M_ERROR)
  WRITE(MSGTEXT, '(A)') ETEXT
  CALL SENDTEXTMSG(M_ERROR)
  ERROR_FLAG = 1
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION SHUTDOWN[DLLEXPORT, STDCALL]()
  USE SIMPARAMS
  USE TEXT
  USE GLOBAL_DATA
  IMPLICIT NONE
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
#endif    
  REAL :: CPUSEC
  INTEGER :: ERRORS
! ----------------------------------------------------------------------
  SHUTDOWN = 0
 
! --- Deallocate memory used during the simulation.
 
#ifndef TSIS_COMPATIBLE
  IF(WTRF) THEN
    CALL WRITE_TRF_FILE(ERRORS)
    SHUTDOWN = ERRORS
  ENDIF
  TIME_PERIOD = 0
#endif

  IF(TYPE_OF_RUN .EQ. 4) THEN
    WRITE(MSGTEXT, '(A)') 'Finished processing animation files.'
    CALL SENDTEXTMSG(M_INFO)
  ELSE
    !write(msgtext, '(a,i)') 'last vehicle: ', LAST_ID_USED
    !call sendtextmsg(m_info)
    CALL CLEANUP
    CALL CPU_TIME(CPUSEC)
    WRITE(MSGTEXT, '(A,F8.2,A)') 'TOTAL CPU TIME     ', CPUSEC - START_CPU, ' SECONDS'
    CALL SENDTEXTMSG(M_INFO)
    WRITE(MSGTEXT, '(A,F8.2,A)') 'TOTAL ELAPSED TIME ', SECNDS(START_TIMER), ' SECONDS'
    CALL SENDTEXTMSG(M_INFO)
#ifdef TSIS_COMPATIBLE
    CALL SIMCALLRTE(RT_SHUTDOWN)
#endif
  ENDIF
  END

! ==================================================================================================
  SUBROUTINE CLEANUP
  USE CORSIM_NODES
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE FREEWAY_VEHICLES
  USE STREET_VEHICLES
  USE ENTRYNODE_DATA
  USE OBJECTS
  USE FREEWAY_NODES
  USE STREET_NODES
  USE SEGMENTS
  USE TIMED_CONTROLLERS
  USE ACTUATED_CONTROLLERS
  USE INCIDENTS
  USE RAMP_METERS
  USE BUS_ROUTE_DATA
  USE EVENTS
  USE PARKING
  USE TURNDATA_MOD
  USE NUMMOEOBJECTS
  USE FREEWAY_DETECTORS
  USE STREET_DETECTORS
  USE DATASTATIONS
  USE BUS_STATION_DATA
  USE TIME_PERIOD_MOES
  USE ENTRYNODE_DATA
  USE PATH_MOD
  USE API_DATA
  USE SIMPARAMS
  USE NODE_TABLE
  USE EV_DATA
! ----------------------------------------------------------------------
#ifndef TSIS_COMPATIBLE
  CALL DEALLOCATE_API_DATA
  CALL CLOSEFILES
#endif
  IF(ALLOCATED(UPNOD)) DEALLOCATE(UPNOD)
  IF(ALLOCATED(DWNOD)) DEALLOCATE(DWNOD)
  IF(ALLOCATED(UPNODE)) DEALLOCATE(UPNODE)
  IF(ALLOCATED(DWNODE)) DEALLOCATE(DWNODE)
  IF(ALLOCATED(NNODES)) DEALLOCATE(NNODES)
  IF(ALLOCATED(PATH_NODES)) DEALLOCATE(PATH_NODES)
  IF(ALLOCATED(AC_SIGNALS)) DEALLOCATE(AC_SIGNALS)
  IF(ALLOCATED(ACSIGNAL_DATA)) DEALLOCATE(ACSIGNAL_DATA)
  IF(ALLOCATED(FTC_SIGNALS)) DEALLOCATE(FTC_SIGNALS)
  CALL DEALLOCATE_NODE_ARRAYS
  CALL EMPTY_QUEUES
  CALL DEALLOCATE_FREEWAY_VEHICLE_ARRAYS
  CALL DEALLOCATE_STREET_VEHICLE_ARRAYS
  CALL DEALLOCATE_MOE_MEMORY
  CALL DEALLOCATE_FREEWAY_LINK_ARRAYS
  CALL DEALLOCATE_STREET_LINK_ARRAYS
  CALL DEALLOCATE_FREEWAY_NODE_ARRAYS
  CALL DEALLOCATE_STREET_NODE_ARRAYS
  CALL DEALLOCATE_OBJECT_LIST
  CALL DEALLOCATE_SEGMENT_ARRAYS
  CALL DEALLOCATE_RAMPMETER_ARRAYS
  CALL DEALLOCATE_AC_ARRAYS
  CALL DEALLOCATE_FTC_ARRAYS
  CALL DEALLOCATE_INCIDENT_ARRAYS
  CALL DEALLOCATE_BUS_ROUTE_DATA_ARRAYS
  CALL DEALLOCATE_EVENT_ARRAYS
  CALL DEALLOCATE_PARKING_ARRAYS
  CALL DEALLOCATE_OBJECT_ARRAYS
  CALL DEALLOCATE_FREEWAY_DETECTOR_ARRAYS
  CALL DEALLOCATE_STREET_DETECTOR_ARRAYS
  CALL DEALLOCATE_DATASTATION_ARRAYS
  CALL DEALLOCATE_BUS_STATION_DATA
  CALL DEALLOCATE_TURNDATA
  CALL DEALLOCATE_TIME_PERIOD_MOES_ARRAYS
  CALL DEALLOCATE_EV_DATA_ARRAYS
  CARPOOL_PCT = 0
  DELAYED_COUNT = 0
  DELAYED_TIME = 0
  ENTRYNODE_IS_USED = .FALSE.
  ERLANGA = 0
  HOV_VIOLATOR_PCT = 0
  LANE_PCT = 0
  MINSEP = 1.2
  TRUCK_PCT = 0
  TYPEDIST = 0
  FLOWRATE = 0
  RETURN
  END
  
  SUBROUTINE CLOSEFILES
  USE SIMPARAMS
  USE TEXT
  IMPLICIT NONE
  INCLUDE 'IOFILES.INC'
  COMMON /GRAPHIO/ TSTEPFILE, TINTERVALFILE
  INTEGER :: TSTEPFILE, TINTERVALFILE
  LOGICAL :: FILE_EXISTS, FILE_ERROR
  IF(TSTEPFILE .EQ. 2) THEN
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_NETWORK_LINKS.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(1, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_LINK_DATA.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(2, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_RAMPMETER_DATA.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(3, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_LIST.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(4, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_DATA.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(5, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_DATA_ARC.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(6, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_DATA_RTW.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(7, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_INCIDENT_DATA.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(8, ERR=20, IOMSG=ETEXT)
    ENDIF
    INQUIRE(FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_DATA_STOPPED.TXT', EXIST=FILE_EXISTS)
    IF(FILE_EXISTS) THEN
      CLOSE(9, ERR=20, IOMSG=ETEXT)
    ENDIF
  ENDIF
10 CONTINUE
  IF(FILE_ERROR) THEN
    WRITE(MSGTEXT,'(A)') 'FILE OPEN ERROR: CLOSEFILES'
    CALL SENDTEXTMSG(M_INFO)
    WRITE(MSGTEXT, '(A)') ETEXT
    CALL SENDTEXTMSG(M_ERROR)
  ENDIF
  GOTO 30
20 CONTINUE
  IF(FILE_ERROR) THEN
    WRITE(MSGTEXT,'(A)') 'FILE CLOSE ERROR: CLOSEFILES'
    CALL SENDTEXTMSG(M_INFO)
    WRITE(MSGTEXT, '(A)') ETEXT
    CALL SENDTEXTMSG(M_ERROR)
  ENDIF
30 CONTINUE  
  RETURN
  END
  
! ==================================================================================================
  SUBROUTINE ABORTCORSIM[DLLEXPORT,STDCALL]()
  USE SIMPARAMS
  IMPLICIT NONE
  EXITFLG = 1
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION SETINPUTNAME[DLLEXPORT, STDCALL](FNAME)
  USE SIMPARAMS
  IMPLICIT NONE
  INTEGER :: LINFLEN, LOUTFLEN
  COMMON /LIOFILES[DLLEXPORT]/ LINFNAME,LOUTFNAME,LINFLEN,LOUTFLEN
  CHARACTER*512 LINFNAME,LOUTFNAME
  STRUCTURE /FILE/
    CHARACTER*512 NAME
    INTEGER LEN
  END STRUCTURE
  RECORD /FILE/ FNAME[REFERENCE]
  LINFNAME = FNAME.NAME
  LINFLEN = FNAME.LEN
  IROOT = INDEX(LINFNAME(1:LINFLEN), '.', BACK = .TRUE.)
  SETINPUTNAME = 0
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION SETMOEFOLDER[DLLEXPORT, STDCALL](FNAME)
  IMPLICIT NONE
  INTEGER :: MOEFLEN
  COMMON /MOES[DLLEXPORT]/ MOEFOLDER, MOEFLEN
  CHARACTER*512 MOEFOLDER
  STRUCTURE /FILE/
    CHARACTER*512 NAME
    INTEGER LEN
  END STRUCTURE
  RECORD /FILE/ FNAME[REFERENCE]
  MOEFOLDER = FNAME.NAME
  MOEFLEN = FNAME.LEN
  SETMOEFOLDER = 0
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION SETIOFLAGS[DLLEXPORT, STDCALL](TSFLAG, TIFLAG, LFLAG, CFLAG)
  USE SIMPARAMS
  IMPLICIT NONE
  COMMON /GRAPHIO/ TSTEPFILE, TINTERVALFILE
  COMMON /LLU6IO/ LU6FLG, CSVFLAG
  INTEGER TSFLAG, TIFLAG, LFLAG, CFLAG
  INTEGER TSTEPFILE, TINTERVALFILE, LU6FLG, CSVFLAG, TRFFLAG
  TSTEPFILE = TSFLAG
  TINTERVALFILE = TIFLAG
  LU6FLG = LFLAG
  CSVFLAG = CFLAG
  SETIOFLAGS = 0
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION SETOUTPUTNAME[DLLEXPORT, STDCALL](FNAME)
  IMPLICIT NONE
  INTEGER :: LINFLEN, LOUTFLEN
  COMMON /LIOFILES[DLLEXPORT]/ LINFNAME,LOUTFNAME,LINFLEN,LOUTFLEN
  CHARACTER*512 LINFNAME,LOUTFNAME
  STRUCTURE /FILE/
    CHARACTER*512 NAME
    INTEGER LEN
  END STRUCTURE
  RECORD /FILE/ FNAME[REFERENCE]
  LOUTFNAME = FNAME.NAME
  LOUTFLEN = FNAME.LEN
  SETOUTPUTNAME = 0
  RETURN
  END

! ==================================================================================================
  SUBROUTINE SIMSTATUS(ISTATUS)
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
  INTEGER :: ISTATUS
  CALL SENDMSG(SIM_STATUS, ISTATUS)
#endif  
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION GETTXDVERSION[DLLEXPORT, STDCALL]()
  ! This matches the version of the TXD system used by CORSIM 5.1
  GETTXDVERSION = 501
  RETURN
  END

! ==================================================================================================
  INTEGER FUNCTION CHECK_INPUT_DATA[DLLEXPORT, STDCALL](ANAME)
  IMPLICIT NONE
 
  STRUCTURE /FILE/
    CHARACTER*512 NAME
    INTEGER LEN
  END STRUCTURE
  RECORD /FILE/ ANAME[REFERENCE]
  INTEGER :: STATUS
       
  INTERFACE
  INTEGER FUNCTION SETINPUTNAME[DLLEXPORT, STDCALL](FNAME)
    STRUCTURE /FILE/
      CHARACTER*512 NAME
      INTEGER LEN
    END STRUCTURE
    RECORD /FILE/ FNAME[REFERENCE]
  END
  INTEGER FUNCTION SETIOFLAGS[DLLEXPORT, STDCALL](TSFLAG, TIFLAG, LFLAG, CFLAG)
    INTEGER TSFLAG, TIFLAG, LFLAG, CFLAG
  END
  INTEGER FUNCTION STARTUP[DLLEXPORT, STDCALL]()
  END
  END INTERFACE
 
  STATUS = SETINPUTNAME(ANAME)
  STATUS = STATUS + SETIOFLAGS(0, 0, 0, 0)
  STATUS = STATUS + STARTUP()
  CHECK_INPUT_DATA = STATUS
  END

  SUBROUTINE SAVE_SIMULATION_DATA(FILE1, FILE2)
  USE SIMPARAMS
  USE ADD_DROP_ALIGNMENTS
  USE BUS_ROUTE_DATA
  USE BUS_STATION_DATA
  USE DATASTATIONS
  USE FREEWAY_DETECTORS
  USE STREET_DETECTORS
  USE EVENTS
  USE GLOBAL_DATA
  USE SEEDS
  USE PEDS
  USE INCIDENTS
  USE DISTRIBUTIONS
  USE OBJECTS
  USE ENTRYNODE_DATA
  USE FREEWAY_NODES
  USE STREET_NODES
  USE PARKING
  USE SEGMENTS
  USE FREEWAY_VEHICLES
  USE STREET_VEHICLES
  USE DRIVERS
  USE VEHICLE_TYPES
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE TIMED_CONTROLLERS
  USE TURNDATA_MOD
  USE FLOWDATA_MOD
  USE QUEUE_MOD
  USE PATH_MOD
  USE RAMP_METERS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: FILE1, FILE2
  LOGICAL :: FIRST = .TRUE.
 
  IF(FIRST) THEN
    CALL SAVE_SIMPARAMS(FILE1)
    CALL SAVE_DRIVERS(FILE1)
    CALL SAVE_ALIGNMENTS(FILE1)
    CALL SAVE_BUS_ROUTE_DATA(FILE1)
    CALL SAVE_EVENT_DATA(FILE1)
    CALL SAVE_GLOBAL_DATA(FILE1)
    CALL SAVE_SEEDS(FILE1)
    CALL SAVE_INCIDENTS(FILE1)
    CALL SAVE_DISTRIBUTIONS(FILE1)
    CALL SAVE_ENTRYNODE_DATA(FILE1)
    CALL SAVE_TURNDATA_MOD(FILE1)
    CALL SAVE_FLOWDATA_MOD(FILE1)
    CALL SAVE_QUEUE_MOD(FILE1)
  ENDIF
  IF(FIRST) WRITE(FILE1) N_FREEWAY_LINKS
  IF(N_FREEWAY_LINKS .GT. 0) THEN
    IF(FIRST) THEN
      CALL SAVE_FREEWAY_NODES(FILE1)
      CALL SAVE_OBJECT_LIST(FILE1)
      CALL SAVE_SEGMENTS(FILE1)
    ENDIF
    CALL SAVE_FREEWAY_LINKS(FILE1, FILE2, FIRST)
    CALL SAVE_DATASTATIONS(FILE1, FILE2, FIRST)
    CALL SAVE_FREEWAY_DETECTOR(FILE1, FILE2, FIRST)
    CALL SAVE_RAMP_METERS(FILE1, FILE2, FIRST)
    CALL SAVE_FREEWAY_VEHICLES(FILE2)
  ENDIF
  IF(FIRST) WRITE(FILE1) N_STREET_LINKS
  IF(N_STREET_LINKS .GT. 0) THEN
    IF(FIRST) THEN
      CALL SAVE_PARKING(FILE1)
      CALL SAVE_VEHICLE_TYPES(FILE1)
      CALL SAVE_PATH_MOD(FILE1)
      CALL SAVE_STREET_NODES(FILE1)
      CALL SAVE_PEDS(FILE1)
    ENDIF
    CALL SAVE_BUS_STATION_DATA(FILE1, FILE2, FIRST)
    CALL SAVE_STREET_DETECTOR(FILE1, FILE2, FIRST)
    CALL SAVE_STREET_LINKS(FILE1, FILE2, FIRST)
    CALL SAVE_TIMED_CONTROLLERS(FILE1, FILE2, FIRST)
    CALL SAVE_STREET_VEHICLES(FILE2)
  ENDIF
  FIRST = .FALSE.
  RETURN
  END
  
  SUBROUTINE RESTORE_SIMULATION_DATA(FILE1, FILE2)
  USE SIMPARAMS
  USE ADD_DROP_ALIGNMENTS
  USE BUS_ROUTE_DATA
  USE BUS_STATION_DATA
  USE DATASTATIONS
  USE FREEWAY_DETECTORS
  USE STREET_DETECTORS
  USE EVENTS
  USE GLOBAL_DATA
  USE SEEDS
  USE PEDS
  USE INCIDENTS
  USE DISTRIBUTIONS
  USE OBJECTS
  USE ENTRYNODE_DATA
  USE FREEWAY_NODES
  USE STREET_NODES
  USE PARKING
  USE SEGMENTS
  USE FREEWAY_VEHICLES
  USE STREET_VEHICLES
  USE DRIVERS
  USE VEHICLE_TYPES
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE TIMED_CONTROLLERS
  USE TURNDATA_MOD
  USE FLOWDATA_MOD
  USE QUEUE_MOD
  USE PATH_MOD
  USE RAMP_METERS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: FILE1, FILE2
 
  CALL RESTORE_SIMPARAMS(FILE1)
  CALL RESTORE_DRIVERS(FILE1)
  CALL RESTORE_ALIGNMENTS(FILE1)
  CALL RESTORE_BUS_ROUTE_DATA(FILE1)
  CALL RESTORE_EVENT_DATA(FILE1)
  CALL RESTORE_GLOBAL_DATA(FILE1)
  CALL RESTORE_SEEDS(FILE1)
  CALL RESTORE_INCIDENTS(FILE1)
  CALL RESTORE_DISTRIBUTIONS(FILE1)
  CALL RESTORE_ENTRYNODE_DATA(FILE1)
  CALL RESTORE_TURNDATA_MOD(FILE1)
  CALL RESTORE_FLOWDATA_MOD(FILE1)
  CALL RESTORE_QUEUE_MOD(FILE1)
  READ(FILE1) N_FREEWAY_LINKS
  IF(N_FREEWAY_LINKS .GT. 0) THEN
    CALL ALLOCATE_FREEWAY_NODE_ARRAYS
    CALL ALLOCATE_FREEWAY_LINK_ARRAYS
    CALL RESTORE_FREEWAY_NODES(FILE1)
    CALL RESTORE_OBJECT_LIST(FILE1)
    CALL RESTORE_SEGMENTS(FILE1)
    CALL RESTORE_FREEWAY_LINKS(FILE1, FILE2)
    CALL RESTORE_DATASTATIONS(FILE1, FILE2)
    CALL RESTORE_FREEWAY_DETECTOR(FILE1, FILE2)
    CALL RESTORE_RAMP_METERS(FILE1, FILE2)
    CALL RESTORE_FREEWAY_VEHICLE(FILE2)
  ENDIF
  READ(FILE1) N_STREET_LINKS
  IF(N_STREET_LINKS .GT. 0) THEN
    CALL ALLOCATE_STREET_LINK_ARRAYS
    CALL RESTORE_PARKING(FILE1)
    CALL RESTORE_VEHICLE_TYPES(FILE1)
    CALL RESTORE_PATH_MOD(FILE1)
    CALL RESTORE_STREET_NODES(FILE1)
    CALL RESTORE_PEDS(FILE1)
    CALL RESTORE_BUS_STATION_DATA(FILE1, FILE2)
    CALL RESTORE_STREET_DETECTOR(FILE1, FILE2)
    CALL RESTORE_STREET_LINKS(FILE1, FILE2)
    CALL RESTORE_TIMED_CONTROLLERS(FILE1, FILE2)
    CALL RESTORE_STREET_VEHICLE(FILE2)
  ENDIF
  RETURN
  END            
   
! ==================================================================================================
  SUBROUTINE YIELD_TIME()
#ifdef TSIS_COMPATIBLE
  IMPLICIT NONE
  INCLUDE 'CORWIN.FI'
  CALL SENDMSG(0, 0)
#endif  
  RETURN
  END

! ==================================================================================================
  SUBROUTINE SIMCALLRTE(MSG)
  IMPLICIT NONE      
  INTEGER, INTENT(IN) :: MSG
#ifdef TSIS_COMPATIBLE
  INCLUDE 'CORWIN.FI'
  CALL SENDMSG(SIM_CALLRTE, MSG)
  RETURN
#endif
  END

!=======================================================================
  INTEGER FUNCTION GETRTECALLSIZE[DLLEXPORT, STDCALL, ALIAS:'GetRTECallSize'](NUM_ELEMS, MAX_STRLEN)
  IMPLICIT INTEGER(A-Q, S-V, X), REAL(R, Z), LOGICAL(W, Y)
  INTEGER NUM_ELEMS  [REFERENCE]
  INTEGER MAX_STRLEN [REFERENCE]
 
! --- CODED    7-28-04 BY T. SIMMERMAN
 
  NUM_ELEMS = 10
  MAX_STRLEN = 20
 
  GETRTECALLSIZE = 0
  END FUNCTION

#ifdef TSIS_COMPATIBLE
!=======================================================================
! Function: GETRTECALL(INDEX, MSG_ID, MSG_NAME, ISIZE)
!
! Description: Returns the RTE Call Point List
!
!
! Arguments: CBUF - [out] character string to hold the list
!
!            ISIZE - [in] size of the list
!
! Returns: int = 0 - success
!=======================================================================
  INTEGER FUNCTION GETRTECALL[DLLEXPORT, STDCALL, ALIAS:'GetRTECall'] (INDEX, MSG_ID, MSG_NAME, ISIZE)
  IMPLICIT INTEGER(A-Q, S-V, X), REAL(R, Z), LOGICAL(W, Y)
  INTEGER         INDEX    [VALUE]
  INTEGER         MSG_ID   [REFERENCE]
  CHARACTER*(ISIZE) MSG_NAME [REFERENCE]
  INTEGER         ISIZE    [VALUE]
  INCLUDE 'CORWIN.FI'
 
  SELECT CASE(INDEX)
  CASE(1)
    MSG_ID = RT_INITIALIZE
    MSG_NAME = RT_INITIALIZE_NAME
  CASE(2)
    MSG_ID = RT_BEGINSIMULATION
    MSG_NAME = RT_BEGINSIMULATION_NAME
  CASE(3)
    MSG_ID = RT_POST_VEHICLE_EMIT
    MSG_NAME = RT_POST_VEHICLE_EMIT_NAME
  CASE(4)
    MSG_ID = RT_PRE_VEHICLEUPDATE
    MSG_NAME = RT_PRE_VEHICLEUPDATE_NAME
  CASE(5)
    MSG_ID = RT_PRE_SIGNALUPDATE
    MSG_NAME = RT_PRE_SIGNALUPDATE_NAME
  CASE(6)
    MSG_ID = RT_SHUTDOWN
    MSG_NAME = RT_SHUTDOWN_NAME
  CASE(7)
    MSG_ID = RT_TIMESTEPCOMPLETE
    MSG_NAME = RT_TIMESTEPCOMPLETE_NAME
  CASE(8)
    MSG_ID = RT_INTERVALCOMPLETE
    MSG_NAME = RT_INTERVALCOMPLETE_NAME
  CASE(9)
    MSG_ID = RT_TIMEPERIODCOMPLETE
    MSG_NAME = RT_TIMEPERIODCOMPLETE_NAME
  CASE(10)
    MSG_ID = RT_SIMULATION_COMPLETE
    MSG_NAME = RT_SIMULATION_COMPLETE_NAME
  END SELECT
 
  GETRTECALL = 0
  END FUNCTION

!=======================================================================
  SUBROUTINE GENERATE_ANIMATION_FILES
  USE SIMPARAMS
  USE RAMP_METERS
  USE FREEWAY_LINKS
  USE STREET_LINKS
  USE INCIDENTS
  USE TEXT
  IMPLICIT NONE
  INCLUDE 'CORWIN.FI'
  INCLUDE 'TXDINTERFACE.FI'
  INCLUDE 'IOFILES.INC'
  INTEGER, ALLOCATABLE :: DRIVERTYPE(:)
  INTEGER, ALLOCATABLE :: VEHICLETYPE(:)
  INTEGER, ALLOCATABLE :: FLEET(:)
  INTEGER, ALLOCATABLE :: LENGTH(:)
  INTEGER :: NV, IV, USN, DSN, TEMP, TP
  INTEGER :: NMETER, IL, ITIME, LAST
  REAL :: INCTIME, TIME1, TIME2
  LOGICAL :: HAS_INCIDENTS = .FALSE.
! ----------------------------------------------------------------------
  OPEN(1, FILE = LINFNAME(1:IROOT-1)//'_LINK_DATA.TXT', STATUS='OLD', ERR=30, IOMSG=ETEXT)
  OPEN(2, FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_DATA.TXT', STATUS='OLD', ERR=30, IOMSG=ETEXT)
  OPEN(3, FILE = LINFNAME(1:IROOT-1)//'_VEHICLE_LIST.TXT', STATUS='OLD', ERR=30, IOMSG=ETEXT)
  IF(NUMBER_OF_RAMPMETERS .NE. 0) OPEN(4, FILE = LINFNAME(1:IROOT-1)//'_RAMPMETER_DATA.TXT', ERR=30, IOMSG=ETEXT)
  OPEN(5, FILE = LINFNAME(1:IROOT-1)//'_INCIDENT_DATA.TXT', STATUS='OLD', ERR=5)
  HAS_INCIDENTS = .TRUE.
5 CONTINUE  
! --- Determine the ID of the last vehicle
  DO
    READ(3, *, END=10, ERR=40, IOMSG=ETEXT) LAST
  ENDDO
10 CONTINUE
  ALLOCATE(DRIVERTYPE(LAST))
  ALLOCATE(VEHICLETYPE(LAST))
  ALLOCATE(FLEET(LAST))
  ALLOCATE(LENGTH(LAST))
  DRIVERTYPE = 0
  VEHICLETYPE = 0
  FLEET = 0
  LENGTH = 0
  REWIND(3)
  DO
    READ(3, *, END=11, ERR=40, IOMSG=ETEXT) IV, TEMP, FLEET(IV), VEHICLETYPE(IV), LENGTH(IV), DRIVERTYPE(IV)
  ENDDO
11 CONTINUE  
  CALL SIMSTATUS(SIM_BEGINSIMULATION)
  TP = 1
  DO ITIME = 0, SIMULATION_END
    IF(MOD(ITIME, TIME_INTERVAL) .EQ. 0) CALL SIMSTATUS(SIM_BEGININTERVAL)
    CALL SIMSTATUS(SIM_BEGINTIMESTEP)
15  READ(1, *, END=25) TIME1, THELINKDATA
    IF(TIME1 .LT. ITIME) GOTO 15
    !WRITE(MSGTEXT, '(A, F10.1)') 'PROCESSING TIMESTEP:', TIME1
    !CALL SENDTEXTMSG(M_INFO)
    IF(TIME1 .EQ. ITIME) THEN
      IF(HAS_INCIDENTS) THEN     
        DO
          READ(5, *, END=20) INCTIME, THELKINCDATA
          IF(INCTIME .EQ. TIME1) THEN
            CALL SENDMSG(SIM_ADDINCIDENT, 0)
          ELSEIF(INCTIME .GT. TIME1) THEN
            BACKSPACE(5)
            EXIT
          ENDIF
        ENDDO
20      CONTINUE  
        REWIND(5)
      ENDIF
      CALL SENDMSG(SIM_LINKSTATEVALID, 0)
      DO NV = 1, THELINKDATA%NUMVEHICLES
21      CONTINUE        
        READ(2, *, ERR=40, IOMSG=ETEXT) TIME2, USN, DSN, &
                   THEVEHDATA%VEHICLEGLOBALID, THEVEHDATA%LANENUMBER, THEVEHDATA%DISTANCEFROMUSN, THEVEHDATA%USNPREVLINK, &
                   THEVEHDATA%TURNCODE, THEVEHDATA%QUEUECODE, THEVEHDATA%ACCELERATION, THEVEHDATA%VELOCITY, THEVEHDATA%LANECHANGESTATUS, &
                   THEVEHDATA%TARGETLANE, THEVEHDATA%DESTINATION, THEVEHDATA%LEADVEHICLEID, THEVEHDATA%FOLLOWVEHICLEID, THEVEHDATA%PREVLANE
        IF(TIME2 .LT. TIME1) GOTO 21
        IV = THEVEHDATA%VEHICLEGLOBALID
        THEVEHDATA%FLEET = FLEET(IV)
        THEVEHDATA%TYPEVEH = VEHICLETYPE(IV)
        THEVEHDATA%VEHICLELENGTH = LENGTH(IV)
        THEVEHDATA%DRIVERTYPE = DRIVERTYPE(IV)
        IF(THELINKDATA%MODELTYPE .EQ. 1) THEN
          IF(THEVEHDATA%LANENUMBER .GE. 16) THEN
            THEVEHDATA%LANENUMBER = THEVEHDATA%LANENUMBER - 7
          ELSEIF(THEVEHDATA%LANENUMBER .GE. 11) THEN
            THEVEHDATA%LANENUMBER = THEVEHDATA%LANENUMBER - 5
          ENDIF
        ELSE
          CALL FIND_STREET_LINK(USN, DSN, IL)
          IF(THEVEHDATA%LANENUMBER .GE. FIRST_FULL_LANE(IL) .AND. THEVEHDATA%LANENUMBER .LE. LAST_FULL_LANE(IL)) THEN
            THEVEHDATA%LANENUMBER = THEVEHDATA%LANENUMBER - NUMBER_RIGHTPOCKETS(IL)
            IF(RTW_EXIT_POINT(IL) .NE. 0) THEN
              THEVEHDATA%LANENUMBER = THEVEHDATA%LANENUMBER - 1
            ENDIF
          ELSEIF(THEVEHDATA%LANENUMBER .EQ. LAST_FULL_LANE(IL) + 1) THEN
            THEVEHDATA%LANENUMBER = 7
          ELSEIF(THEVEHDATA%LANENUMBER .EQ. LAST_FULL_LANE(IL) + 2) THEN
            THEVEHDATA%LANENUMBER = 6
          ELSEIF(THEVEHDATA%LANENUMBER .EQ. FIRST_FULL_LANE(IL) - 1) THEN
            THEVEHDATA%LANENUMBER = 7 - NUMBER_LEFTPOCKETS(IL)
          ELSEIF(THEVEHDATA%LANENUMBER .EQ. FIRST_FULL_LANE(IL) - 2) THEN
            THEVEHDATA%LANENUMBER = 6 - NUMBER_LEFTPOCKETS(IL)
          ENDIF
          
          DSN = USN
          USN = THEVEHDATA%USNPREVLINK
          CALL FIND_STREET_LINK(USN, DSN, IL)
          IF(IL .NE. 0 .AND. IL .LE. N_STREET_LINKS) THEN
            IF(THEVEHDATA%PREVLANE .GE. FIRST_FULL_LANE(IL) .AND. THEVEHDATA%PREVLANE .LE. LAST_FULL_LANE(IL)) THEN
              THEVEHDATA%PREVLANE = THEVEHDATA%PREVLANE - NUMBER_RIGHTPOCKETS(IL)
              IF(RTW_EXIT_POINT(IL) .NE. 0) THEN
                THEVEHDATA%PREVLANE = THEVEHDATA%PREVLANE - 1
              ENDIF
            ELSEIF(THEVEHDATA%PREVLANE .EQ. LAST_FULL_LANE(IL) + 1) THEN
              THEVEHDATA%PREVLANE = 7
            ELSEIF(THEVEHDATA%PREVLANE .EQ. LAST_FULL_LANE(IL) + 2) THEN
              THEVEHDATA%PREVLANE = 6
            ELSEIF(THEVEHDATA%PREVLANE .EQ. FIRST_FULL_LANE(IL) - 1) THEN
              THEVEHDATA%PREVLANE = 7 - NUMBER_LEFTPOCKETS(IL)
            ELSEIF(THEVEHDATA%PREVLANE .EQ. FIRST_FULL_LANE(IL) - 2) THEN
              THEVEHDATA%PREVLANE = 6 - NUMBER_LEFTPOCKETS(IL)
            ENDIF
          ENDIF
        ENDIF
        CALL SENDMSG(SIM_ADDVEHICLE, 0)
      ENDDO
      CALL SIMSTATUS(SIM_LINKCOMPLETE)
      GOTO 15
    ELSE
      BACKSPACE(1)
    ENDIF
25  CONTINUE
    DO NMETER = 1, NUMBER_OF_RAMPMETERS
      READ(4, *, ERR=40, IOMSG=ETEXT, END=26) TIME2, THELINKDATA
      IL = RAMPMETERS(NMETER)%LINK
      THELINKDATA%USN = FUSN(IL)
      THELINKDATA%DSN = FDSN(IL)
      CALL SENDMSG(SIM_ADDRAMPMETER, 0)
    ENDDO
    CALL SIMSTATUS(SIM_TIMESTEPCOMPLETE)
    IF(ITIME .GT. 0 .AND. MOD(ITIME, TIME_INTERVAL) .EQ. 0) THEN
      CALL SENDTIMEINTERVALDATA
      CALL SIMSTATUS(SIM_INTERVALCOMPLETE)
    ENDIF
    IF(ITIME .EQ. SUM(TPSECONDS(1:TP))) THEN
      TP = TP + 1
      CALL SIMSTATUS(SIM_TIMEPERIODCOMPLETE)
    ENDIF
26 CONTINUE
  ENDDO
  CALL SIMSTATUS(SIM_COMPLETE)
  CLOSE(1)
  CLOSE(2)
  CLOSE(3)
  IF(NUMBER_OF_RAMPMETERS .NE. 0) CLOSE(4)
  IF(HAS_INCIDENTS) CLOSE(5)
  RETURN
30 WRITE(MSGTEXT, '(A)') 'FILE OPEN ERROR : GENERATE_ANIMATION_FILES'
  CALL SENDTEXTMSG(M_ERROR)
  WRITE(MSGTEXT, '(A)') ETEXT
  CALL SENDTEXTMSG(M_ERROR)
  RETURN
40 WRITE(MSGTEXT, '(A)') 'FILE READ ERROR : GENERATE_ANIMATION_FILES'
  CALL SENDTEXTMSG(M_ERROR)
  WRITE(MSGTEXT, '(A)') ETEXT
  CALL SENDTEXTMSG(M_ERROR)
  RETURN
  END     
#endif

! ==================================================================================================
    SUBROUTINE GENERATE_PKEVENTS
! ----------------------------------------------------------------------
! --- Generate Parking Events. Create a blockage for each event. 
! ----------------------------------------------------------------------
    USE SIMPARAMS
    USE STREET_LINKS
    USE STREET_VEHICLES
    USE EVENTS
    USE SEEDS
    USE PARKING
    IMPLICIT NONE
    INTEGER :: I, IL, TIME, IRN, N
    REAL :: RNDNUM, DURATION
    DO I = 1, NUMBER_OF_PARKING_ZONES
      TIME = 0
      IL = PARKING_ZONE_LINK(I)
      N = 0
      IF(PARK_RIGHT_LEN(I) .NE. 0) N = N + 1
      IF(PARK_LEFT_LEN(I) .NE. 0) N = N + 1

! --- Determine start time and duration for parking events on the link.

      DO 

! --- Calculate the next event start time using a decile distribution.

        CALL STREET_RANDOM(SSEED, RNDNUM)
        IRN = RNDNUM * 10 + 1
        TIME = TIME + PKHEADWAY_MULT(IRN) * 3600 / PARK_FREQ(I) / N
        IF(TIME .GE. SIMULATION_END) EXIT

! --- Store parking events on the right side.

        IF(PARK_RIGHT_LEN(I) .NE. 0) THEN

! --- Calculate the duration of the next event using a decile distribution.

          CALL STREET_RANDOM(SSEED, RNDNUM)
          IRN = RNDNUM * 10 + 1
          DURATION = PKDURATION_MULT(IRN) * PARK_DURATION(I)

! --- If the duration is significant create a blockage.

          IF(DURATION .GE. TIMESTEP) THEN
            CALL NEW_EVENT
            EVENT_BEGIN_TIME(NUMBER_OF_EVENTS) = TIME
            EVENT_END_TIME(NUMBER_OF_EVENTS) = TIME + DURATION
            CALL STREET_RANDOM(SSEED, RNDNUM)
            EVENT_LOCATION(NUMBER_OF_EVENTS) = PARK_RIGHT_START(I) + RNDNUM * PARK_RIGHT_LEN(I)
            EVENT_LINK(NUMBER_OF_EVENTS) = IL
            EVENT_LANE(NUMBER_OF_EVENTS) = 1
            EVENT_TYPE(NUMBER_OF_EVENTS) = 3
          ENDIF
        ENDIF

! --- Store parking events on the left side.

        IF(PARK_LEFT_LEN(I) .NE. 0) THEN

! --- Calculate the duration of the next event using a decile distribution.

          CALL STREET_RANDOM(SSEED, RNDNUM)
          IRN = RNDNUM * 10 + 1
          DURATION = PKDURATION_MULT(IRN) * PARK_DURATION(I) / 10.

! --- If the duration is significant create a blockage.

          IF(DURATION .GE. TIMESTEP) THEN
            CALL NEW_EVENT
            EVENT_BEGIN_TIME(NUMBER_OF_EVENTS) = TIME
            EVENT_END_TIME(NUMBER_OF_EVENTS) = TIME + DURATION
            CALL STREET_RANDOM(SSEED, RNDNUM)
            EVENT_LOCATION(NUMBER_OF_EVENTS) = PARK_LEFT_START(I) + RNDNUM * PARK_LEFT_LEN(I)
            EVENT_LINK(NUMBER_OF_EVENTS) = IL
            EVENT_LANE(NUMBER_OF_EVENTS) = LAST_FULL_LANE(IL)
            EVENT_TYPE(NUMBER_OF_EVENTS) = 3
          ENDIF
        ENDIF
      ENDDO
    ENDDO          
    RETURN
    END

! ==================================================================================================
    SUBROUTINE GENERATE_STEVENTS
! ----------------------------------------------------------------------
! --- Generate Short-Term Events. Create a blockage for each event. 
! --- Short-Term Events must be located in lane 1.
! ----------------------------------------------------------------------
    USE SIMPARAMS
    USE STREET_LINKS
    USE STREET_VEHICLES
    USE SEEDS
    USE EVENTS
    IMPLICIT NONE
    INTEGER :: IL, TIME, IRN
    REAL :: RNDNUM, DURATION
! ----------------------------------------------------------------------
    DO IL = 1, N_STREET_LINKS
      TIME = 0
      IF(STE_FREQ(IL) .NE. 0) THEN

! --- Determine start time and duration for events on the link.

        DO 
          TIME = TIME + 3600 / STE_FREQ(IL)
          IF(TIME .GE. SIMULATION_END) EXIT

! --- Calculate the duration of the next event using a decile distribution.

          CALL STREET_RANDOM(SSEED, RNDNUM)
          IRN = RNDNUM * 10 + 1
          DURATION = STE_MULT(IRN) * STE_DURATION(IL)

! --- If the duration is significant create a blockage.

          IF(DURATION .GE. TIMESTEP) THEN
            CALL NEW_EVENT
            EVENT_BEGIN_TIME(NUMBER_OF_EVENTS) = TIME
            EVENT_END_TIME(NUMBER_OF_EVENTS) = TIME + DURATION
            CALL STREET_RANDOM(SSEED, RNDNUM)
            EVENT_LOCATION(NUMBER_OF_EVENTS) = RNDNUM * SLENGTH(IL)
            EVENT_LINK(NUMBER_OF_EVENTS) = IL
            EVENT_LANE(NUMBER_OF_EVENTS) = 1
            EVENT_TYPE(NUMBER_OF_EVENTS) = 4
          ENDIF
        ENDDO
      ENDIF
    ENDDO          
    RETURN
    END

    
